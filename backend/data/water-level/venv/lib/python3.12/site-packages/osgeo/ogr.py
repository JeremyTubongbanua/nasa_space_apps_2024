# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ogr
else:
    import _ogr

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


wkb25DBit = _ogr.wkb25DBit

wkb25Bit = _ogr.wkb25Bit

wkbUnknown = _ogr.wkbUnknown

wkbPoint = _ogr.wkbPoint

wkbLineString = _ogr.wkbLineString

wkbPolygon = _ogr.wkbPolygon

wkbMultiPoint = _ogr.wkbMultiPoint

wkbMultiLineString = _ogr.wkbMultiLineString

wkbMultiPolygon = _ogr.wkbMultiPolygon

wkbGeometryCollection = _ogr.wkbGeometryCollection

wkbCircularString = _ogr.wkbCircularString

wkbCompoundCurve = _ogr.wkbCompoundCurve

wkbCurvePolygon = _ogr.wkbCurvePolygon

wkbMultiCurve = _ogr.wkbMultiCurve

wkbMultiSurface = _ogr.wkbMultiSurface

wkbCurve = _ogr.wkbCurve

wkbSurface = _ogr.wkbSurface

wkbPolyhedralSurface = _ogr.wkbPolyhedralSurface

wkbTIN = _ogr.wkbTIN

wkbTriangle = _ogr.wkbTriangle

wkbNone = _ogr.wkbNone

wkbLinearRing = _ogr.wkbLinearRing

wkbCircularStringZ = _ogr.wkbCircularStringZ

wkbCompoundCurveZ = _ogr.wkbCompoundCurveZ

wkbCurvePolygonZ = _ogr.wkbCurvePolygonZ

wkbMultiCurveZ = _ogr.wkbMultiCurveZ

wkbMultiSurfaceZ = _ogr.wkbMultiSurfaceZ

wkbCurveZ = _ogr.wkbCurveZ

wkbSurfaceZ = _ogr.wkbSurfaceZ

wkbPolyhedralSurfaceZ = _ogr.wkbPolyhedralSurfaceZ

wkbTINZ = _ogr.wkbTINZ

wkbTriangleZ = _ogr.wkbTriangleZ

wkbPointM = _ogr.wkbPointM

wkbLineStringM = _ogr.wkbLineStringM

wkbPolygonM = _ogr.wkbPolygonM

wkbMultiPointM = _ogr.wkbMultiPointM

wkbMultiLineStringM = _ogr.wkbMultiLineStringM

wkbMultiPolygonM = _ogr.wkbMultiPolygonM

wkbGeometryCollectionM = _ogr.wkbGeometryCollectionM

wkbCircularStringM = _ogr.wkbCircularStringM

wkbCompoundCurveM = _ogr.wkbCompoundCurveM

wkbCurvePolygonM = _ogr.wkbCurvePolygonM

wkbMultiCurveM = _ogr.wkbMultiCurveM

wkbMultiSurfaceM = _ogr.wkbMultiSurfaceM

wkbCurveM = _ogr.wkbCurveM

wkbSurfaceM = _ogr.wkbSurfaceM

wkbPolyhedralSurfaceM = _ogr.wkbPolyhedralSurfaceM

wkbTINM = _ogr.wkbTINM

wkbTriangleM = _ogr.wkbTriangleM

wkbPointZM = _ogr.wkbPointZM

wkbLineStringZM = _ogr.wkbLineStringZM

wkbPolygonZM = _ogr.wkbPolygonZM

wkbMultiPointZM = _ogr.wkbMultiPointZM

wkbMultiLineStringZM = _ogr.wkbMultiLineStringZM

wkbMultiPolygonZM = _ogr.wkbMultiPolygonZM

wkbGeometryCollectionZM = _ogr.wkbGeometryCollectionZM

wkbCircularStringZM = _ogr.wkbCircularStringZM

wkbCompoundCurveZM = _ogr.wkbCompoundCurveZM

wkbCurvePolygonZM = _ogr.wkbCurvePolygonZM

wkbMultiCurveZM = _ogr.wkbMultiCurveZM

wkbMultiSurfaceZM = _ogr.wkbMultiSurfaceZM

wkbCurveZM = _ogr.wkbCurveZM

wkbSurfaceZM = _ogr.wkbSurfaceZM

wkbPolyhedralSurfaceZM = _ogr.wkbPolyhedralSurfaceZM

wkbTINZM = _ogr.wkbTINZM

wkbTriangleZM = _ogr.wkbTriangleZM

wkbPoint25D = _ogr.wkbPoint25D

wkbLineString25D = _ogr.wkbLineString25D

wkbPolygon25D = _ogr.wkbPolygon25D

wkbMultiPoint25D = _ogr.wkbMultiPoint25D

wkbMultiLineString25D = _ogr.wkbMultiLineString25D

wkbMultiPolygon25D = _ogr.wkbMultiPolygon25D

wkbGeometryCollection25D = _ogr.wkbGeometryCollection25D

OFTInteger = _ogr.OFTInteger

OFTIntegerList = _ogr.OFTIntegerList

OFTReal = _ogr.OFTReal

OFTRealList = _ogr.OFTRealList

OFTString = _ogr.OFTString

OFTStringList = _ogr.OFTStringList

OFTWideString = _ogr.OFTWideString

OFTWideStringList = _ogr.OFTWideStringList

OFTBinary = _ogr.OFTBinary

OFTDate = _ogr.OFTDate

OFTTime = _ogr.OFTTime

OFTDateTime = _ogr.OFTDateTime

OFTInteger64 = _ogr.OFTInteger64

OFTInteger64List = _ogr.OFTInteger64List

OFSTNone = _ogr.OFSTNone

OFSTBoolean = _ogr.OFSTBoolean

OFSTInt16 = _ogr.OFSTInt16

OFSTFloat32 = _ogr.OFSTFloat32

OFSTJSON = _ogr.OFSTJSON

OFSTUUID = _ogr.OFSTUUID

OJUndefined = _ogr.OJUndefined

OJLeft = _ogr.OJLeft

OJRight = _ogr.OJRight

OFDT_CODED = _ogr.OFDT_CODED

OFDT_RANGE = _ogr.OFDT_RANGE

OFDT_GLOB = _ogr.OFDT_GLOB

OFDSP_DEFAULT_VALUE = _ogr.OFDSP_DEFAULT_VALUE

OFDSP_DUPLICATE = _ogr.OFDSP_DUPLICATE

OFDSP_GEOMETRY_RATIO = _ogr.OFDSP_GEOMETRY_RATIO

OFDMP_DEFAULT_VALUE = _ogr.OFDMP_DEFAULT_VALUE

OFDMP_SUM = _ogr.OFDMP_SUM

OFDMP_GEOMETRY_WEIGHTED = _ogr.OFDMP_GEOMETRY_WEIGHTED

wkbXDR = _ogr.wkbXDR

wkbNDR = _ogr.wkbNDR

NullFID = _ogr.NullFID

ALTER_NAME_FLAG = _ogr.ALTER_NAME_FLAG

ALTER_TYPE_FLAG = _ogr.ALTER_TYPE_FLAG

ALTER_WIDTH_PRECISION_FLAG = _ogr.ALTER_WIDTH_PRECISION_FLAG

ALTER_NULLABLE_FLAG = _ogr.ALTER_NULLABLE_FLAG

ALTER__FLAG = _ogr.ALTER__FLAG

ALTER_DEFAULT_FLAG = _ogr.ALTER_DEFAULT_FLAG

ALTER_UNIQUE_FLAG = _ogr.ALTER_UNIQUE_FLAG

ALTER_DOMAIN_FLAG = _ogr.ALTER_DOMAIN_FLAG

ALTER_ALTERNATIVE_NAME_FLAG = _ogr.ALTER_ALTERNATIVE_NAME_FLAG

ALTER_COMMENT_FLAG = _ogr.ALTER_COMMENT_FLAG

ALTER_ALL_FLAG = _ogr.ALTER_ALL_FLAG

ALTER_GEOM_FIELD_DEFN_NAME_FLAG = _ogr.ALTER_GEOM_FIELD_DEFN_NAME_FLAG

ALTER_GEOM_FIELD_DEFN_TYPE_FLAG = _ogr.ALTER_GEOM_FIELD_DEFN_TYPE_FLAG

ALTER_GEOM_FIELD_DEFN_NULLABLE_FLAG = _ogr.ALTER_GEOM_FIELD_DEFN_NULLABLE_FLAG

ALTER_GEOM_FIELD_DEFN_SRS_FLAG = _ogr.ALTER_GEOM_FIELD_DEFN_SRS_FLAG

ALTER_GEOM_FIELD_DEFN_SRS_COORD_EPOCH_FLAG = _ogr.ALTER_GEOM_FIELD_DEFN_SRS_COORD_EPOCH_FLAG

ALTER_GEOM_FIELD_DEFN_ALL_FLAG = _ogr.ALTER_GEOM_FIELD_DEFN_ALL_FLAG

F_VAL_NULL = _ogr.F_VAL_NULL

F_VAL_GEOM_TYPE = _ogr.F_VAL_GEOM_TYPE

F_VAL_WIDTH = _ogr.F_VAL_WIDTH

F_VAL_ALLOW_NULL_WHEN_DEFAULT = _ogr.F_VAL_ALLOW_NULL_WHEN_DEFAULT

F_VAL_ALL = _ogr.F_VAL_ALL

TZFLAG_UNKNOWN = _ogr.TZFLAG_UNKNOWN

TZFLAG_LOCALTIME = _ogr.TZFLAG_LOCALTIME

TZFLAG_MIXED_TZ = _ogr.TZFLAG_MIXED_TZ

TZFLAG_UTC = _ogr.TZFLAG_UTC

GGT_COUNT_NOT_NEEDED = _ogr.GGT_COUNT_NOT_NEEDED

GGT_STOP_IF_MIXED = _ogr.GGT_STOP_IF_MIXED

GGT_GEOMCOLLECTIONZ_TINZ = _ogr.GGT_GEOMCOLLECTIONZ_TINZ

OLCRandomRead = _ogr.OLCRandomRead

OLCSequentialWrite = _ogr.OLCSequentialWrite

OLCRandomWrite = _ogr.OLCRandomWrite

OLCFastSpatialFilter = _ogr.OLCFastSpatialFilter

OLCFastFeatureCount = _ogr.OLCFastFeatureCount

OLCFastGetExtent = _ogr.OLCFastGetExtent

OLCFastGetExtent3D = _ogr.OLCFastGetExtent3D

OLCCreateField = _ogr.OLCCreateField

OLCDeleteField = _ogr.OLCDeleteField

OLCReorderFields = _ogr.OLCReorderFields

OLCAlterFieldDefn = _ogr.OLCAlterFieldDefn

OLCAlterGeomFieldDefn = _ogr.OLCAlterGeomFieldDefn

OLCTransactions = _ogr.OLCTransactions

OLCDeleteFeature = _ogr.OLCDeleteFeature

OLCUpsertFeature = _ogr.OLCUpsertFeature

OLCUpdateFeature = _ogr.OLCUpdateFeature

OLCFastSetNextByIndex = _ogr.OLCFastSetNextByIndex

OLCStringsAsUTF8 = _ogr.OLCStringsAsUTF8

OLCIgnoreFields = _ogr.OLCIgnoreFields

OLCCreateGeomField = _ogr.OLCCreateGeomField

OLCCurveGeometries = _ogr.OLCCurveGeometries

OLCMeasuredGeometries = _ogr.OLCMeasuredGeometries

OLCZGeometries = _ogr.OLCZGeometries

OLCRename = _ogr.OLCRename

OLCFastGetArrowStream = _ogr.OLCFastGetArrowStream

OLCFastWriteArrowBatch = _ogr.OLCFastWriteArrowBatch

ODsCCreateLayer = _ogr.ODsCCreateLayer

ODsCDeleteLayer = _ogr.ODsCDeleteLayer

ODsCCreateGeomFieldAfterCreateLayer = _ogr.ODsCCreateGeomFieldAfterCreateLayer

ODsCCurveGeometries = _ogr.ODsCCurveGeometries

ODsCTransactions = _ogr.ODsCTransactions

ODsCEmulatedTransactions = _ogr.ODsCEmulatedTransactions

ODsCMeasuredGeometries = _ogr.ODsCMeasuredGeometries

ODsCZGeometries = _ogr.ODsCZGeometries

ODsCRandomLayerRead = _ogr.ODsCRandomLayerRead

ODsCRandomLayerWrite = _ogr.ODsCRandomLayerWrite

ODsCAddFieldDomain = _ogr.ODsCAddFieldDomain

ODsCDeleteFieldDomain = _ogr.ODsCDeleteFieldDomain

ODsCUpdateFieldDomain = _ogr.ODsCUpdateFieldDomain

ODrCCreateDataSource = _ogr.ODrCCreateDataSource

ODrCDeleteDataSource = _ogr.ODrCDeleteDataSource

OLMD_FID64 = _ogr.OLMD_FID64

GEOS_PREC_NO_TOPO = _ogr.GEOS_PREC_NO_TOPO

GEOS_PREC_KEEP_COLLAPSED = _ogr.GEOS_PREC_KEEP_COLLAPSED

OGRERR_NONE = _ogr.OGRERR_NONE

OGRERR_NOT_ENOUGH_DATA = _ogr.OGRERR_NOT_ENOUGH_DATA

OGRERR_NOT_ENOUGH_MEMORY = _ogr.OGRERR_NOT_ENOUGH_MEMORY

OGRERR_UNSUPPORTED_GEOMETRY_TYPE = _ogr.OGRERR_UNSUPPORTED_GEOMETRY_TYPE

OGRERR_UNSUPPORTED_OPERATION = _ogr.OGRERR_UNSUPPORTED_OPERATION

OGRERR_CORRUPT_DATA = _ogr.OGRERR_CORRUPT_DATA

OGRERR_FAILURE = _ogr.OGRERR_FAILURE

OGRERR_UNSUPPORTED_SRS = _ogr.OGRERR_UNSUPPORTED_SRS

OGRERR_INVALID_HANDLE = _ogr.OGRERR_INVALID_HANDLE

OGRERR_NON_EXISTING_FEATURE = _ogr.OGRERR_NON_EXISTING_FEATURE


def GetUseExceptions(*args):
    r"""GetUseExceptions() -> int"""
    return _ogr.GetUseExceptions(*args)

def _GetExceptionsLocal(*args):
    r"""_GetExceptionsLocal() -> int"""
    return _ogr._GetExceptionsLocal(*args)

def _SetExceptionsLocal(*args):
    r"""_SetExceptionsLocal(int bVal)"""
    return _ogr._SetExceptionsLocal(*args)

def _UseExceptions(*args):
    r"""_UseExceptions()"""
    return _ogr._UseExceptions(*args)

def _DontUseExceptions(*args):
    r"""_DontUseExceptions()"""
    return _ogr._DontUseExceptions(*args)

def _UserHasSpecifiedIfUsingExceptions(*args):
    r"""_UserHasSpecifiedIfUsingExceptions() -> int"""
    return _ogr._UserHasSpecifiedIfUsingExceptions(*args)

class ExceptionMgr(object):
    """
    Context manager to manage Python Exception state
    for GDAL/OGR/OSR/GNM.

    Separate exception state is maintained for each
    module (gdal, ogr, etc), and this class appears independently
    in all of them. This is built in top of calls to the older
    UseExceptions()/DontUseExceptions() functions.

    Example::

        >>> print(gdal.GetUseExceptions())
        0
        >>> with gdal.ExceptionMgr():
        ...     # Exceptions are now in use
        ...     print(gdal.GetUseExceptions())
        1
        >>>
        >>> # Exception state has now been restored
        >>> print(gdal.GetUseExceptions())
        0

    """
    def __init__(self, useExceptions=True):
        """
        Save whether or not this context will be using exceptions
        """
        self.requestedUseExceptions = useExceptions

    def __enter__(self):
        """
        On context entry, save the current GDAL exception state, and
        set it to the state requested for the context

        """
        self.currentUseExceptions = _GetExceptionsLocal()
        _SetExceptionsLocal(self.requestedUseExceptions)
        if ExceptionMgr.__module__ == "osgeo.gdal":
            try:
                from . import gdal_array
            except ImportError:
                gdal_array = None
            if gdal_array:
                gdal_array._SetExceptionsLocal(self.requestedUseExceptions)

    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        On exit, restore the GDAL/OGR/OSR/GNM exception state which was
        current on entry to the context
        """
        _SetExceptionsLocal(self.currentUseExceptions)
        if ExceptionMgr.__module__ == "osgeo.gdal":
            try:
                from . import gdal_array
            except ImportError:
                gdal_array = None
            if gdal_array:
                gdal_array._SetExceptionsLocal(self.currentUseExceptions)




def UseExceptions():
    """ Enable exceptions in all GDAL related modules (osgeo.gdal, osgeo.ogr, osgeo.osr, osgeo.gnm).
        Note: prior to GDAL 3.7, this only affected the calling module"""

    try:
        from . import gdal
        gdal._UseExceptions()
    except ImportError:
        pass
    try:
        from . import gdal_array
        gdal_array._UseExceptions()
    except ImportError:
        pass
    try:
        from . import ogr
        ogr._UseExceptions()
    except ImportError:
        pass
    try:
        from . import osr
        osr._UseExceptions()
    except ImportError:
        pass
    try:
        from . import gnm
        gnm._UseExceptions()
    except ImportError:
        pass

def DontUseExceptions():
    """ Disable exceptions in all GDAL related modules (osgeo.gdal, osgeo.ogr, osgeo.osr, osgeo.gnm).
        Note: prior to GDAL 3.7, this only affected the calling module"""

    try:
        from . import gdal
        gdal._DontUseExceptions()
    except ImportError:
        pass
    try:
        from . import gdal_array
        gdal_array._DontUseExceptions()
    except ImportError:
        pass
    try:
        from . import ogr
        ogr._DontUseExceptions()
    except ImportError:
        pass
    try:
        from . import osr
        osr._DontUseExceptions()
    except ImportError:
        pass
    try:
        from . import gnm
        gnm._DontUseExceptions()
    except ImportError:
        pass




hasWarnedAboutUserHasNotSpecifiedIfUsingExceptions = False

def _WarnIfUserHasNotSpecifiedIfUsingExceptions():
    from . import gdal
    if not hasattr(gdal, "hasWarnedAboutUserHasNotSpecifiedIfUsingExceptions") and not _UserHasSpecifiedIfUsingExceptions():
        gdal.hasWarnedAboutUserHasNotSpecifiedIfUsingExceptions = True
        import warnings
        warnings.warn(
            "Neither ogr.UseExceptions() nor ogr.DontUseExceptions() has been explicitly called. " +
            "In GDAL 4.0, exceptions will be enabled by default.", FutureWarning)

from . import osr
class MajorObject(object):
    r"""Proxy of C++ GDALMajorObjectShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetDescription(self, *args):
        r"""GetDescription(MajorObject self) -> char const *"""
        return _ogr.MajorObject_GetDescription(self, *args)

    def SetDescription(self, *args):
        r"""SetDescription(MajorObject self, char const * pszNewDesc)"""
        return _ogr.MajorObject_SetDescription(self, *args)

    def GetMetadataDomainList(self, *args):
        r"""GetMetadataDomainList(MajorObject self) -> char **"""
        return _ogr.MajorObject_GetMetadataDomainList(self, *args)

    def GetMetadata_Dict(self, *args):
        r"""GetMetadata_Dict(MajorObject self, char const * pszDomain="") -> char **"""
        return _ogr.MajorObject_GetMetadata_Dict(self, *args)

    def GetMetadata_List(self, *args):
        r"""GetMetadata_List(MajorObject self, char const * pszDomain="") -> char **"""
        return _ogr.MajorObject_GetMetadata_List(self, *args)

    def SetMetadata(self, *args):
        r"""
        SetMetadata(MajorObject self, char ** papszMetadata, char const * pszDomain="") -> CPLErr
        SetMetadata(MajorObject self, char * pszMetadataString, char const * pszDomain="") -> CPLErr
        """
        return _ogr.MajorObject_SetMetadata(self, *args)

    def GetMetadataItem(self, *args):
        r"""GetMetadataItem(MajorObject self, char const * pszName, char const * pszDomain="") -> char const *"""
        return _ogr.MajorObject_GetMetadataItem(self, *args)

    def SetMetadataItem(self, *args):
        r"""SetMetadataItem(MajorObject self, char const * pszName, char const * pszValue, char const * pszDomain="") -> CPLErr"""
        return _ogr.MajorObject_SetMetadataItem(self, *args)

    def GetMetadata(self, domain=''):
      if domain[:4] == 'xml:':
        return self.GetMetadata_List(domain)
      return self.GetMetadata_Dict(domain)


# Register MajorObject in _ogr:
_ogr.MajorObject_swigregister(MajorObject)

def GetGEOSVersionMajor(*args):
    r"""GetGEOSVersionMajor() -> int"""
    return _ogr.GetGEOSVersionMajor(*args)

def GetGEOSVersionMinor(*args):
    r"""GetGEOSVersionMinor() -> int"""
    return _ogr.GetGEOSVersionMinor(*args)

def GetGEOSVersionMicro(*args):
    r"""GetGEOSVersionMicro() -> int"""
    return _ogr.GetGEOSVersionMicro(*args)
class StyleTable(object):
    r"""Proxy of C++ OGRStyleTableShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(StyleTable self) -> StyleTable"""
        _ogr.StyleTable_swiginit(self, _ogr.new_StyleTable(*args))
    __swig_destroy__ = _ogr.delete_StyleTable

    def AddStyle(self, *args):
        r"""AddStyle(StyleTable self, char const * pszName, char const * pszStyleString) -> int"""
        return _ogr.StyleTable_AddStyle(self, *args)

    def LoadStyleTable(self, *args):
        r"""LoadStyleTable(StyleTable self, char const * utf8_path) -> int"""
        return _ogr.StyleTable_LoadStyleTable(self, *args)

    def SaveStyleTable(self, *args):
        r"""SaveStyleTable(StyleTable self, char const * utf8_path) -> int"""
        return _ogr.StyleTable_SaveStyleTable(self, *args)

    def Find(self, *args):
        r"""Find(StyleTable self, char const * pszName) -> char const *"""
        return _ogr.StyleTable_Find(self, *args)

    def ResetStyleStringReading(self, *args):
        r"""ResetStyleStringReading(StyleTable self)"""
        return _ogr.StyleTable_ResetStyleStringReading(self, *args)

    def GetNextStyle(self, *args):
        r"""GetNextStyle(StyleTable self) -> char const *"""
        return _ogr.StyleTable_GetNextStyle(self, *args)

    def GetLastStyleName(self, *args):
        r"""GetLastStyleName(StyleTable self) -> char const *"""
        return _ogr.StyleTable_GetLastStyleName(self, *args)

# Register StyleTable in _ogr:
_ogr.StyleTable_swigregister(StyleTable)
class Driver(MajorObject):
    r"""Proxy of C++ OGRDriverShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    name = property(_ogr.Driver_name_get, doc=r"""name : p.q(const).char""")

    def CreateDataSource(self, *args, **kwargs):
        r"""CreateDataSource(Driver self, char const * utf8_path, char ** options=None) -> DataSource"""
        return _ogr.Driver_CreateDataSource(self, *args, **kwargs)

    def CopyDataSource(self, *args, **kwargs):
        r"""CopyDataSource(Driver self, DataSource copy_ds, char const * utf8_path, char ** options=None) -> DataSource"""
        return _ogr.Driver_CopyDataSource(self, *args, **kwargs)

    def Open(self, *args, **kwargs):
        r"""Open(Driver self, char const * utf8_path, int update=0) -> DataSource"""

        _WarnIfUserHasNotSpecifiedIfUsingExceptions()


        return _ogr.Driver_Open(self, *args, **kwargs)


    def DeleteDataSource(self, *args):
        r"""DeleteDataSource(Driver self, char const * utf8_path) -> int"""
        return _ogr.Driver_DeleteDataSource(self, *args)

    def TestCapability(self, *args):
        r"""TestCapability(Driver self, char const * cap) -> bool"""
        return _ogr.Driver_TestCapability(self, *args)

    def GetName(self, *args):
        r"""GetName(Driver self) -> char const *"""
        return _ogr.Driver_GetName(self, *args)

    def Register(self, *args):
        r"""Register(Driver self)"""
        return _ogr.Driver_Register(self, *args)

    def Deregister(self, *args):
        r"""Deregister(Driver self)"""
        return _ogr.Driver_Deregister(self, *args)

# Register Driver in _ogr:
_ogr.Driver_swigregister(Driver)
class DataSource(MajorObject):
    r"""

    Python proxy of a vector :cpp:class:`GDALDataset`.

    Since GDAL 3.8, a DataSource can be used as a context manager.
    When exiting the context, the DataSource will be closed and
    features will be written to disk.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    name = property(_ogr.DataSource_name_get, doc=r"""name : p.q(const).char""")
    __swig_destroy__ = _ogr.delete_DataSource

    def Close(self, *args):
        r"""
        Close(DataSource self) -> CPLErr

        Closes opened dataset and releases allocated resources.

        This method can be used to force the dataset to close
        when one more references to the dataset are still
        reachable. If Close is never called, the dataset will
        be closed automatically during garbage collection.

        """
        val = _ogr.DataSource_Close(self, *args)

        self.thisown = 0
        self.this = None
        self._invalidate_layers()


        return val


    def GetRefCount(self, *args):
        r"""
        GetRefCount(DataSource self) -> int
        int
        OGR_DS_GetRefCount(OGRDataSourceH hDataSource) 
        """
        return _ogr.DataSource_GetRefCount(self, *args)

    def GetSummaryRefCount(self, *args):
        r"""
        GetSummaryRefCount(DataSource self) -> int
        int
        OGR_DS_GetSummaryRefCount(OGRDataSourceH hDataSource) 
        """
        return _ogr.DataSource_GetSummaryRefCount(self, *args)

    def GetLayerCount(self, *args):
        r"""
        GetLayerCount(DataSource self) -> int
        int
        OGR_DS_GetLayerCount(OGRDataSourceH hDS)

        Get the number of layers in this data source.

        Deprecated Use GDALDatasetGetLayerCount() in GDAL 2.0

        Parameters
        -----------
        hDS:
            handle to the data source from which to get the number of
            layers.

        Returns
        --------
        int:
            layer count.

        """
        return _ogr.DataSource_GetLayerCount(self, *args)

    def GetDriver(self, *args):
        r"""
        GetDriver(DataSource self) -> Driver
        OGRSFDriverH
        OGR_DS_GetDriver(OGRDataSourceH hDS)

        Returns the driver that the dataset was opened with.

        NOTE: Starting with GDAL 2.0, it is NOT safe to cast the returned
        handle to OGRSFDriver\*. If a C++ object is needed, the handle should
        be cast to GDALDriver\*.

        Deprecated Use GDALGetDatasetDriver() in GDAL 2.0

        Parameters
        -----------
        hDS:
            handle to the datasource

        Returns
        --------
        OGRSFDriverH:
            NULL if driver info is not available, or pointer to a driver owned by
            the OGRSFDriverManager.

        """
        return _ogr.DataSource_GetDriver(self, *args)

    def GetName(self, *args):
        r"""
        GetName(DataSource self) -> char const *
        const char\*
        OGR_DS_GetName(OGRDataSourceH hDS)

        Returns the name of the data source.

        This string should be sufficient to open the data source if passed to
        the same OGRSFDriver that this data source was opened with, but it
        need not be exactly the same string that was used to open the data
        source. Normally this is a filename.

        Deprecated Use GDALGetDescription() in GDAL 2.0

        Parameters
        -----------
        hDS:
            handle to the data source to get the name from.

        Returns
        --------
        str:
            pointer to an internal name string which should not be modified or
            freed by the caller.

        """
        return _ogr.DataSource_GetName(self, *args)

    def DeleteLayer(self, value) -> "OGRErr":
        """
        DeleteLayer(DataSource self, value) -> OGRErr

        Delete the indicated layer from the datasource.

        For more details: :c:func:`OGR_DS_DeleteLayer`

        Parameters
        -----------
        value: str | int
            index or name of the layer to delete.

        Returns
        -------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success, or :py:const:`osgeo.ogr.OGRERR_UNSUPPORTED_OPERATION` if deleting
            layers is not supported for this datasource.
        """

        if isinstance(value, str):
            for i in range(self.GetLayerCount()):
                lyr = self.GetLayer(i)
                if lyr.GetName() == value:
                    return _ogr.DataSource_DeleteLayer(self, i)
            raise ValueError("Layer %s not found to delete" % value)
        elif isinstance(value, int):
            return _ogr.DataSource_DeleteLayer(self, value)
        else:
            raise TypeError("Input %s is not of String or Int type" % type(value))



    def SyncToDisk(self, *args):
        r"""
        SyncToDisk(DataSource self) -> OGRErr
        OGRErr
        OGR_DS_SyncToDisk(OGRDataSourceH hDS)

        Flush pending changes to disk.

        See GDALDataset::FlushCache() 
        """
        return _ogr.DataSource_SyncToDisk(self, *args)

    def FlushCache(self, *args):
        r"""FlushCache(DataSource self)"""
        return _ogr.DataSource_FlushCache(self, *args)

    def CreateLayer(self, *args, **kwargs):
        r"""
        CreateLayer(DataSource self, char const * name, SpatialReference srs=None, OGRwkbGeometryType geom_type=wkbUnknown, char ** options=None) -> Layer
        OGRLayerH
        OGR_DS_CreateLayer(OGRDataSourceH hDS, const char \*pszName,
        OGRSpatialReferenceH hSpatialRef, OGRwkbGeometryType eType, char
        \*\*papszOptions)

        This function attempts to create a new layer on the data source with
        the indicated name, coordinate system, geometry type.

        The papszOptions argument can be used to control driver specific
        creation options. These options are normally documented in the format
        specific documentation.

        Deprecated Use GDALDatasetCreateLayer() in GDAL 2.0

        Parameters
        -----------
        hDS:
            The dataset handle.pszName:  the name for the new layer. This should ideally not match
            any existing layer on the datasource.
        hSpatialRef:
            handle to the coordinate system to use for the new
            layer, or NULL if no coordinate system is available. The driver might
            only increase the reference counter of the object to take ownership,
            and not make a full copy, so do not use OSRDestroySpatialReference(),
            but OSRRelease() instead when you are done with the object.
        eType:
            the geometry type for the layer. Use wkbUnknown if there are
            no constraints on the types geometry to be written.
        papszOptions:
            a StringList of name=value options. Options are driver
            specific, and driver information can be found at the following
            url:http://www.gdal.org/ogr_formats.html


        Returns
        --------
        OGRLayerH:
            NULL is returned on failure, or a new OGRLayer handle on success.

        """
        val = _ogr.DataSource_CreateLayer(self, *args, **kwargs)

        self._add_layer_ref(val)


        return val


    def CopyLayer(self, *args, **kwargs):
        r"""
        CopyLayer(DataSource self, Layer src_layer, char const * new_name, char ** options=None) -> Layer
        OGRLayerH
        OGR_DS_CopyLayer(OGRDataSourceH hDS, OGRLayerH hSrcLayer, const char
        \*pszNewName, char \*\*papszOptions)

        Duplicate an existing layer.

        This function creates a new layer, duplicate the field definitions of
        the source layer and then duplicate each features of the source layer.
        The papszOptions argument can be used to control driver specific
        creation options. These options are normally documented in the format
        specific documentation. The source layer may come from another
        dataset.

        Deprecated Use GDALDatasetCopyLayer() in GDAL 2.0

        Parameters
        -----------
        hDS:
            handle to the data source where to create the new layer
        hSrcLayer:
            handle to the source layer.
        pszNewName:
            the name of the layer to create.
        papszOptions:
            a StringList of name=value options. Options are driver
            specific.

        Returns
        -------
        OGRLayerH:
            a handle to the layer, or NULL if an error occurs.

        """
        val = _ogr.DataSource_CopyLayer(self, *args, **kwargs)

        self._add_layer_ref(val)


        return val


    def GetLayerByIndex(self, *args):
        r"""GetLayerByIndex(DataSource self, int index=0) -> Layer"""
        val = _ogr.DataSource_GetLayerByIndex(self, *args)

        self._add_layer_ref(val)


        return val


    def GetLayerByName(self, *args):
        r"""
        GetLayerByName(DataSource self, char const * layer_name) -> Layer
        OGRLayerH
        OGR_DS_GetLayerByName(OGRDataSourceH hDS, const char \*pszLayerName)

        Fetch a layer by name.

        The returned layer remains owned by the OGRDataSource and should not
        be deleted by the application.

        Deprecated Use GDALDatasetGetLayerByName() in GDAL 2.0

        Parameters
        -----------
        hDS:
            handle to the data source from which to get the layer.
        pszLayerName:
            Layer the layer name of the layer to fetch.


        Returns
        --------
        OGRLayerH:
            a handle to the layer, or NULL if the layer is not found or an error
            occurs.

        """
        val = _ogr.DataSource_GetLayerByName(self, *args)

        self._add_layer_ref(val)


        return val


    def TestCapability(self, *args):
        r"""
        TestCapability(DataSource self, char const * cap) -> bool
        int
        OGR_DS_TestCapability(OGRDataSourceH hDS, const char \*pszCapability)

        Test if capability is available.

        One of the following data source capability names can be passed into
        this function, and a TRUE or FALSE value will be returned indicating
        whether or not the capability is available for this object.

        ODsCCreateLayer: True if this datasource can create new layers.

        ODsCDeleteLayer: True if this datasource can delete existing layers.

        ODsCCreateGeomFieldAfterCreateLayer: True if the layers of this
        datasource support CreateGeomField() just after layer creation.

        ODsCCurveGeometries: True if this datasource supports writing curve
        geometries. (GDAL 2.0). In that case, OLCCurveGeometries must also be
        declared in layers of that dataset.

        The #define macro forms of the capability names should be used in
        preference to the strings themselves to avoid misspelling.

        Deprecated Use GDALDatasetTestCapability() in GDAL 2.0

        Parameters
        -----------
        hDS:
            handle to the data source against which to test the capability.
        pszCapability:
            the capability to test.

        Returns
        --------
        int:
            TRUE if capability available otherwise FALSE.

        """
        return _ogr.DataSource_TestCapability(self, *args)

    def ExecuteSQL(self, statement, spatialFilter=None, dialect="", keep_ref_on_ds=False):
        """ExecuteSQL(self, statement, spatialFilter: ogr.Geometry = None, dialect: Optional[str] = "", keep_ref_on_ds=False) -> ogr.Layer

        Execute a SQL statement against the dataset

        The result of a SQL query is:
          - None (or an exception if exceptions are enabled) for statements
            that are in error
          - or None for statements that have no results set,
          - or a ogr.Layer handle representing a results set from the query.

        Note that this ogr.Layer is in addition to the layers in the data store
        and must be released with ReleaseResultSet() before the data source is closed
        (destroyed).

        Starting with GDAL 3.7, this method can also be used as a context manager,
        as a convenient way of automatically releasing the returned result layer.

        For more information on the SQL dialect supported internally by OGR
        review the OGR SQL document (:ref:`ogr_sql_sqlite_dialect`)
        Some drivers (i.e. Oracle and PostGIS) pass the SQL directly through to the
        underlying RDBMS.

        The SQLITE dialect can also be used (:ref:`sql_sqlite_dialect`)

        Parameters
        ----------
        statement:
            the SQL statement to execute (e.g "SELECT * FROM layer")
        spatialFilter:
            a geometry which represents a spatial filter. Can be None
        dialect:
            allows control of the statement dialect. If set to None or empty string,
            the OGR SQL engine will be used, except for RDBMS drivers that will
            use their dedicated SQL engine, unless OGRSQL is explicitly passed as
            the dialect. The SQLITE dialect can also be used.
        keep_ref_on_ds:
            whether the returned layer should keep a (strong) reference on
            the current dataset. Cf example 2 for a use case.

        Returns
        -------
        ogr.Layer:
            a ogr.Layer containing the results of the query, that will be
            automatically released when the context manager goes out of scope.

        Examples
        --------
        1. Use as a context manager:

        >>> with ds.ExecuteSQL("SELECT * FROM layer") as lyr:
        ...     print(lyr.GetFeatureCount())

        2. Use keep_ref_on_ds=True to return an object that keeps a reference to its dataset:

        >>> def get_sql_lyr():
        ...     return gdal.OpenEx("test.shp").ExecuteSQL("SELECT * FROM test", keep_ref_on_ds=True)
        ...
        ... with get_sql_lyr() as lyr:
        ...     print(lyr.GetFeatureCount())
        """

        sql_lyr = _ogr.DataSource_ExecuteSQL(self, statement, spatialFilter, dialect)
        if sql_lyr:
            import weakref
            sql_lyr._to_release = True
            sql_lyr._dataset_weak_ref = weakref.ref(self)
            if keep_ref_on_ds:
                sql_lyr._dataset_strong_ref = self
        return sql_lyr



    def AbortSQL(self, *args):
        r"""AbortSQL(DataSource self) -> OGRErr"""
        return _ogr.DataSource_AbortSQL(self, *args)

    def ReleaseResultSet(self, sql_lyr):
        """ReleaseResultSet(self, sql_lyr: ogr.Layer)

        Release ogr.Layer returned by ExecuteSQL() (when not called as an execution manager)

        The sql_lyr object is invalidated after this call.

        Parameters
        ----------
        sql_lyr:
            ogr.Layer got with ExecuteSQL()
        """

        if sql_lyr and not hasattr(sql_lyr, "_to_release"):
            raise Exception("This layer was not returned by ExecuteSQL() and should not be released with ReleaseResultSet()")
        _ogr.DataSource_ReleaseResultSet(self, sql_lyr)
    # Invalidates the layer
        if sql_lyr:
            sql_lyr.thisown = None
            sql_lyr.this = None



    def GetStyleTable(self, *args):
        r"""
        GetStyleTable(DataSource self) -> StyleTable
        OGRStyleTableH
        OGR_DS_GetStyleTable(OGRDataSourceH hDS)

        Get style table. 
        """
        return _ogr.DataSource_GetStyleTable(self, *args)

    def SetStyleTable(self, *args):
        r"""
        SetStyleTable(DataSource self, StyleTable table)
        void
        OGR_DS_SetStyleTable(OGRDataSourceH hDS, OGRStyleTableH hStyleTable)

        Set style table. 
        """
        return _ogr.DataSource_SetStyleTable(self, *args)

    def StartTransaction(self, *args, **kwargs):
        r"""StartTransaction(DataSource self, int force=FALSE) -> OGRErr"""
        return _ogr.DataSource_StartTransaction(self, *args, **kwargs)

    def CommitTransaction(self, *args):
        r"""CommitTransaction(DataSource self) -> OGRErr"""
        return _ogr.DataSource_CommitTransaction(self, *args)

    def RollbackTransaction(self, *args):
        r"""RollbackTransaction(DataSource self) -> OGRErr"""
        return _ogr.DataSource_RollbackTransaction(self, *args)


    def Destroy(self):
      "Once called, self has effectively been destroyed.  Do not access. For backwards compatibility only"
      _ogr.delete_DataSource(self)
      self.thisown = 0
      self.this = None
      self._invalidate_layers()

    def Release(self):
      "Once called, self has effectively been destroyed.  Do not access. For backwards compatibility only"
      _ogr.delete_DataSource(self)
      self.thisown = 0
      self.this = None
      self._invalidate_layers()

    def Reference(self):
      "For backwards compatibility only."
      return self.Reference()

    def Dereference(self):
      "For backwards compatibility only."
      self.Dereference()

    def __len__(self):
        """Returns the number of layers on the datasource"""
        return self.GetLayerCount()

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.Close()

    def __del__(self):
        self._invalidate_layers()

    def __getitem__(self, value):
        """Support dictionary, list, and slice -like access to the datasource.
        ds[0] would return the first layer on the datasource.
        ds['aname'] would return the layer named "aname".
        ds[0:4] would return a list of the first four layers."""
        if isinstance(value, slice):
            output = []
            step = value.step if value.step else 1
            for i in range(value.start, value.stop, step):
                lyr = self.GetLayer(i)
                if lyr is None:
                    return output
                output.append(lyr)
            return output
        if isinstance(value, int):
            if value > len(self) - 1:
                raise IndexError
            return self.GetLayer(value)
        elif isinstance(value, str):
            return self.GetLayer(value)
        else:
            raise TypeError('Input %s is not of String or Int type' % type(value))

    def GetLayer(self, iLayer=0):
        """Return the layer given an index or a name"""

        _WarnIfUserHasNotSpecifiedIfUsingExceptions()

        if isinstance(iLayer, str):
            return self.GetLayerByName(str(iLayer))
        elif isinstance(iLayer, int):
            return self.GetLayerByIndex(iLayer)
        else:
            raise TypeError("Input %s is not of String or Int type" % type(iLayer))

    def _invalidate_layers(self, lyr = None):
        if hasattr(self, '_layer_references'):
            for lyr in self._layer_references:
                lyr.this = None


    def _add_layer_ref(self, lyr):
        if not lyr:
            return

        if not hasattr(self, '_layer_references'):
            import weakref

            self._layer_references = weakref.WeakSet()

        self._layer_references.add(lyr)


# Register DataSource in _ogr:
_ogr.DataSource_swigregister(DataSource)
class ArrowArray(object):
    r"""Proxy of C++ ArrowArray class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(ArrowArray self) -> ArrowArray"""
        _ogr.ArrowArray_swiginit(self, _ogr.new_ArrowArray(*args))
    __swig_destroy__ = _ogr.delete_ArrowArray

    def _getPtr(self, *args):
        r"""_getPtr(ArrowArray self) -> VoidPtrAsLong"""
        return _ogr.ArrowArray__getPtr(self, *args)

    def GetChildrenCount(self, *args):
        r"""GetChildrenCount(ArrowArray self) -> GIntBig"""
        return _ogr.ArrowArray_GetChildrenCount(self, *args)

    def GetLength(self, *args):
        r"""GetLength(ArrowArray self) -> GIntBig"""
        return _ogr.ArrowArray_GetLength(self, *args)

# Register ArrowArray in _ogr:
_ogr.ArrowArray_swigregister(ArrowArray)
class ArrowSchema(object):
    r"""Proxy of C++ ArrowSchema class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(ArrowSchema self) -> ArrowSchema"""
        _ogr.ArrowSchema_swiginit(self, _ogr.new_ArrowSchema(*args))
    __swig_destroy__ = _ogr.delete_ArrowSchema

    def _getPtr(self, *args):
        r"""_getPtr(ArrowSchema self) -> VoidPtrAsLong"""
        return _ogr.ArrowSchema__getPtr(self, *args)

    def GetName(self, *args):
        r"""GetName(ArrowSchema self) -> char const *"""
        return _ogr.ArrowSchema_GetName(self, *args)

    def GetChildrenCount(self, *args):
        r"""GetChildrenCount(ArrowSchema self) -> GIntBig"""
        return _ogr.ArrowSchema_GetChildrenCount(self, *args)

    def GetChild(self, *args):
        r"""GetChild(ArrowSchema self, int iChild) -> ArrowSchema"""
        return _ogr.ArrowSchema_GetChild(self, *args)

# Register ArrowSchema in _ogr:
_ogr.ArrowSchema_swigregister(ArrowSchema)
class ArrowArrayStream(object):
    r"""Proxy of C++ ArrowArrayStream class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_ArrowArrayStream

    def GetSchema(self, *args):
        r"""GetSchema(ArrowArrayStream self) -> ArrowSchema"""
        return _ogr.ArrowArrayStream_GetSchema(self, *args)

    def GetNextRecordBatch(self, *args):
        r"""GetNextRecordBatch(ArrowArrayStream self, char ** options=None) -> ArrowArray"""
        return _ogr.ArrowArrayStream_GetNextRecordBatch(self, *args)

# Register ArrowArrayStream in _ogr:
_ogr.ArrowArrayStream_swigregister(ArrowArrayStream)
class Layer(MajorObject):
    r"""Proxy of C++ OGRLayerShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetDataset(self, *args):
        r"""
        GetDataset(Layer self) -> GDALDatasetShadow *

        Return the dataset associated with this layer.

        For more details: :cpp:func:`OGR_L_GetDataset`

        Returns
        -------
        Dataset:
            Dataset or None

        """
        return _ogr.Layer_GetDataset(self, *args)

    def Rename(self, *args):
        r"""Rename(Layer self, char const * new_name) -> OGRErr"""
        return _ogr.Layer_Rename(self, *args)

    def GetRefCount(self, *args):
        r"""
        GetRefCount(Layer self) -> int

        For more details: :cpp:func:`OGR_L_GetRefCount`

        """
        return _ogr.Layer_GetRefCount(self, *args)

    def SetSpatialFilter(self, *args):
        r"""
        SetSpatialFilter(Layer self, Geometry filter)
        SetSpatialFilter(Layer self, int iGeomField, Geometry filter)

        Set a new spatial filter.

        For more details:

        - :cpp:func:`OGR_L_SetSpatialFilter`
        - :cpp:func:`OGR_L_SetSpatialFilterEx`

        Parameters
        -----------
        iGeomField: int, optional
            index of the geometry field on which the spatial filter operates.
        filter: Geometry
            The geometry to use as a filtering region. None may
            be passed indicating that the current spatial filter should be
            cleared, but no new one instituted.

        """
        return _ogr.Layer_SetSpatialFilter(self, *args)

    def SetSpatialFilterRect(self, *args):
        r"""
        SetSpatialFilterRect(Layer self, double minx, double miny, double maxx, double maxy)
        SetSpatialFilterRect(Layer self, int iGeomField, double minx, double miny, double maxx, double maxy)

        Set a new rectangular spatial filter.

        For more details:

        - :cpp:func:`OGR_L_SetSpatialFilterRect`
        - :cpp:func:`OGR_L_SetSpatialFilterRectEx`

        Parameters
        -----------
        iGeomField: int, optional
            index of the geometry field on which the spatial filter operates.
        minx: float
            the minimum X coordinate for the rectangular region.
        miny: float
            the minimum Y coordinate for the rectangular region.
        maxx: float
            the maximum X coordinate for the rectangular region.
        maxy: float
            the maximum Y coordinate for the rectangular region.

        """
        return _ogr.Layer_SetSpatialFilterRect(self, *args)

    def GetSpatialFilter(self, *args):
        r"""
        GetSpatialFilter(Layer self) -> Geometry

        This function returns the current spatial filter for this layer.

        For more details: :cpp:func:`OGR_L_GetSpatialFilter`

        Returns
        --------
        Geometry:
            The spatial filter geometry.

        """
        return _ogr.Layer_GetSpatialFilter(self, *args)

    def SetAttributeFilter(self, *args):
        r"""
        SetAttributeFilter(Layer self, char * filter_string) -> OGRErr

        Set a new attribute query.

        For more details: :cpp:func:`OGR_L_SetAttributeFilter`

        Parameters
        -----------
        filter_string: str
            query in restricted SQL WHERE format, or None to clear the
            current query.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` if successfully installed,
            or an error code if the query expression is in error,
            or some other failure occurs.

        """
        return _ogr.Layer_SetAttributeFilter(self, *args)

    def ResetReading(self, *args):
        r"""
        ResetReading(Layer self)

        Reset feature reading to start on the first feature.

        For more details: :cpp:func:`OGR_L_ResetReading`

        """
        return _ogr.Layer_ResetReading(self, *args)

    def GetName(self, *args):
        r"""
        GetName(Layer self) -> char const *

        Return the layer name.

        For more details: :cpp:func:`OGR_L_GetName`

        Returns
        --------
        str:
            The layer name

        """
        return _ogr.Layer_GetName(self, *args)

    def GetGeomType(self, *args):
        r"""
        GetGeomType(Layer self) -> OGRwkbGeometryType

        Return the layer geometry type.

        For more details: :cpp:func:`OGR_L_GetGeomType`

        Returns
        --------
        int:
            The geometry type code. The types can be found with
            'osgeo.ogr.wkb' prefix. For example :py:const:`osgeo.ogr.wkbPolygon`.

        """
        return _ogr.Layer_GetGeomType(self, *args)

    def GetGeometryColumn(self, *args):
        r"""
        GetGeometryColumn(Layer self) -> char const *

        This method returns the name of the underlying database column being
        used as the geometry column, or '' if not supported.

        For more details: :cpp:func:`OGR_L_GetGeometryColumn`

        Returns
        --------
        str:
            geometry column name.

        """
        return _ogr.Layer_GetGeometryColumn(self, *args)

    def GetFIDColumn(self, *args):
        r"""
        GetFIDColumn(Layer self) -> char const *

        This method returns the name of the underlying database column being
        used as the FID column, or '' if not supported.

        For more details: :cpp:func:`OGR_L_GetFIDColumn`

        Returns
        --------
        str:
            fid column name.

        """
        return _ogr.Layer_GetFIDColumn(self, *args)

    def GetFeature(self, *args):
        r"""
        GetFeature(Layer self, GIntBig fid) -> Feature

        Fetch a feature by its identifier.

        For more details: :cpp:func:`OGR_L_GetFeature`

        Use :py:func:`TestCapability` with (:py:const:`osgeo.ogr.OLCRandomRead`)
        to establish if this layer supports efficient random access reading via
        :py:func:`GetFeature`; However, the call should always work if the feature exists.

        Sequential reads (with :py:func:`GetNextFeature`) are generally
        considered interrupted by a :py:func:`GetFeature` call.

        Parameters
        -----------
        fid: int
            The feature id of the feature to read.

        Returns
        --------
        Feature:
            A new feature now owned by the caller, or None on failure.
            The returned feature should be deleted with :py:func:`Destroy`.

        """
        return _ogr.Layer_GetFeature(self, *args)

    def GetNextFeature(self, *args):
        r"""
        GetNextFeature(Layer self) -> Feature

        Fetch the next available feature from this layer.

        For more details: :cpp:func:`OGR_L_GetNextFeature`

        Returns
        --------
        Feature:
            A feature or None if no more features are available.

        """
        return _ogr.Layer_GetNextFeature(self, *args)

    def SetNextByIndex(self, *args):
        r"""
        SetNextByIndex(Layer self, GIntBig new_index) -> OGRErr

        Move read cursor to the nIndex'th feature in the current resultset.

        For more details: :cpp:func:`OGR_L_SetNextByIndex`

        Parameters
        -----------
        new_index: int
            The index indicating how many steps into the result set to seek.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success or an error code.

        """
        return _ogr.Layer_SetNextByIndex(self, *args)

    def SetFeature(self, *args):
        r"""
        SetFeature(Layer self, Feature feature) -> OGRErr

        Rewrite an existing feature.

        For more details: :cpp:func:`OGR_L_SetFeature`

        To set a feature, but create it if it doesn't exist see :py:meth:`.Layer.UpsertFeature`.

        Parameters
        -----------
        feature: Feature
            The feature to write.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` if the operation works,
            otherwise an appropriate error code
            (e.g :py:const:`osgeo.ogr.OGRERR_NON_EXISTING_FEATURE` if the
            feature does not exist).

        """
        return _ogr.Layer_SetFeature(self, *args)

    def CreateFeature(self, *args):
        r"""
        CreateFeature(Layer self, Feature feature) -> OGRErr

        Create and write a new feature within a layer.

        For more details: :cpp:func:`OGR_L_CreateFeature`

        To create a feature, but set it if it exists see :py:meth:`.Layer.UpsertFeature`.

        Parameters
        -----------
        feature: Feature
            The feature to write to disk.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_CreateFeature(self, *args)

    def UpsertFeature(self, *args):
        r"""
        UpsertFeature(Layer self, Feature feature) -> OGRErr

        Rewrite an existing feature or create a new feature within a layer.

        For more details: :cpp:func:`OGR_L_UpsertFeature`

        Parameters
        -----------
        feature: Feature
            The feature to write to disk.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_UpsertFeature(self, *args)

    def UpdateFeature(self, *args):
        r"""UpdateFeature(Layer self, Feature feature, int nUpdatedFieldsCount, int nUpdatedGeomFieldsCount, bool bUpdateStyleString) -> OGRErr"""
        return _ogr.Layer_UpdateFeature(self, *args)

    def DeleteFeature(self, *args):
        r"""
        DeleteFeature(Layer self, GIntBig fid) -> OGRErr

        Delete feature from layer.

        For more details: :cpp:func:`OGR_L_DeleteFeature`

        Parameters
        -----------
        fid: int
            The feature id to be deleted from the layer

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` if the operation works,
            otherwise an appropriate error code
            (e.g :py:const:`osgeo.ogr.OGRERR_NON_EXISTING_FEATURE`)
            if the feature does not exist.

        """
        return _ogr.Layer_DeleteFeature(self, *args)

    def SyncToDisk(self, *args):
        r"""
        SyncToDisk(Layer self) -> OGRErr

        Flush pending changes to disk.

        For more details: :cpp:func:`OGR_L_SyncToDisk`

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` if no error occurs
            (even if nothing is done) or an error code.

        """
        return _ogr.Layer_SyncToDisk(self, *args)

    def GetLayerDefn(self, *args):
        r"""
        GetLayerDefn(Layer self) -> FeatureDefn

        Fetch the schema information for this layer.

        For more details: :cpp:func:`OGR_L_GetLayerDefn`

        Returns
        --------
        FeatureDefn:
            The feature definition.

        """
        return _ogr.Layer_GetLayerDefn(self, *args)

    def GetFeatureCount(self, *args, **kwargs):
        r"""
        GetFeatureCount(Layer self, int force=1) -> GIntBig

        Fetch the feature count in this layer.

        For more details: :cpp:func:`OGR_L_GetFeatureCount`

        Parameters
        -----------
        force: int
            Flag indicating whether the count should be computed even if
            it is expensive.

        Returns
        --------
        int:
            Feature count, -1 if count not known.

        """
        return _ogr.Layer_GetFeatureCount(self, *args, **kwargs)

    def GetExtent(self, *args, **kwargs):
        r"""
        GetExtent(Layer self, int force=1, int can_return_null=0, int geom_field=0)

        Fetch the extent of this layer.

        For more details:

        - :cpp:func:`OGR_L_GetExtent`
        - :cpp:func:`OGR_L_GetExtentEx`

        .. warning:: Check the return order of the bounds.

        Parameters
        -----------
        force: int, default=False
            Flag indicating whether the extent should be computed even if
            it is expensive.
        can_return_null: int, default=False
            Whether None can be returned in the response.
        geom_field: int, default=0
            Ithe index of the geometry field on which to compute the extent.
            Can be iterated over using :py:func:`range` and :py:func:`GetGeomFieldCount`.

        Returns
        --------
        minx: float
        maxx: float
        miny: float
        maxy: float

        """
        return _ogr.Layer_GetExtent(self, *args, **kwargs)

    def GetExtent3D(self, *args, **kwargs):
        r"""GetExtent3D(Layer self, int force=1, int can_return_null=0, int geom_field=0)"""
        return _ogr.Layer_GetExtent3D(self, *args, **kwargs)

    def TestCapability(self, *args):
        r"""
        TestCapability(Layer self, char const * cap) -> bool

        Test if this layer supported the named capability.

        For more details: :cpp:func:`OGR_L_TestCapability`

        Parameters
        -----------
        cap: str
            The name of the capability to test. These can
            be found in the `osgeo.ogr` namespace. For example,
            :py:const:`osgeo.ogr.OLCRandomRead`.

        Returns
        --------
        int:
            True if the layer has the requested capability, or False otherwise.
            Will return False for any unrecognized capabilities.

        """
        return _ogr.Layer_TestCapability(self, *args)

    def CreateField(self, *args, **kwargs):
        r"""
        CreateField(Layer self, FieldDefn field_def, int approx_ok=1) -> OGRErr

        Create a new field on a layer.

        For more details: :cpp:func:`OGR_L_CreateField`

        Parameters
        -----------
        field_def: FieldDefn
            The field definition to write to disk.
        approx_ok: bool, default=True
            If True, the field may be created in a slightly different
            form depending on the limitations of the format driver.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_CreateField(self, *args, **kwargs)

    def DeleteField(self, *args):
        r"""
        DeleteField(Layer self, int iField) -> OGRErr

        Delete an existing field on a layer.

        For more details: :cpp:func:`OGR_L_DeleteField`

        Parameters
        -----------
        iField: int
            index of the field to delete.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_DeleteField(self, *args)

    def ReorderField(self, *args):
        r"""
        ReorderField(Layer self, int iOldFieldPos, int iNewFieldPos) -> OGRErr

        Reorder an existing field on a layer.

        For more details: :cpp:func:`OGR_L_ReorderField`

        Parameters
        -----------
        iOldFieldPos: int
            previous position of the field to move. Must be in the
            range [0,GetFieldCount()-1].
        iNewFieldPos: int
            new position of the field to move. Must be in the range
            [0,GetFieldCount()-1].

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_ReorderField(self, *args)

    def ReorderFields(self, *args):
        r"""
        ReorderFields(Layer self, int nList) -> OGRErr

        Reorder all the fields of a layer.

        For more details: :cpp:func:`OGR_L_ReorderFields`

        Parameters
        -----------
        nList: list[int]
            A list of GetLayerDefn().GetFieldCount()
            elements which is a permutation of
            [0, GetLayerDefn().GetFieldCount()-1].

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_ReorderFields(self, *args)

    def AlterFieldDefn(self, *args):
        r"""
        AlterFieldDefn(Layer self, int iField, FieldDefn field_def, int nFlags) -> OGRErr

        Alter the definition of an existing field on a layer.

        For more details: :cpp:func:`OGR_L_AlterFieldDefn`

        Parameters
        -----------
        iField: int
            index of the field whose definition must be altered.
        field_def: FieldDefn
            new field definition
        nFlags: int
            Combination of
            :py:const:`osgeo.ogr.ALTER_NAME_FLAG`,
            :py:const:`osgeo.ogr.ALTER_TYPE_FLAG`,
            :py:const:`osgeo.ogr.ALTER_WIDTH_PRECISION_FLAG`,
            :py:const:`osgeo.ogr.ALTER_NULLABLE_FLAG` and
            :py:const:`osgeo.ogr.ALTER_DEFAULT_FLAG`
            to indicate which of the name and/or type and/or width and precision
            fields and/or nullability from the new field definition must be taken
            into account.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_AlterFieldDefn(self, *args)

    def AlterGeomFieldDefn(self, *args):
        r"""AlterGeomFieldDefn(Layer self, int iGeomField, GeomFieldDefn field_def, int nFlags) -> OGRErr"""
        return _ogr.Layer_AlterGeomFieldDefn(self, *args)

    def CreateGeomField(self, *args, **kwargs):
        r"""
        CreateGeomField(Layer self, GeomFieldDefn field_def, int approx_ok=1) -> OGRErr

        Create a new geometry field on a layer.

        For more details: :cpp:func:`OGR_L_CreateGeomField`

        Parameters
        -----------
        field_def: GeomFieldDefn
            The geometry field definition to write to disk.
        approx_ok: bool, default=True
            If True, the field may be created in a slightly different
            form depending on the limitations of the format driver.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_CreateGeomField(self, *args, **kwargs)

    def StartTransaction(self, *args):
        r"""
        StartTransaction(Layer self) -> OGRErr

        For datasources which support transactions, this creates a transaction.

        For more details: :cpp:func:`OGR_L_StartTransaction`

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_StartTransaction(self, *args)

    def CommitTransaction(self, *args):
        r"""
        CommitTransaction(Layer self) -> OGRErr

        For datasources which support transactions, this commits a transaction.

        For more details: :cpp:func:`OGR_L_CommitTransaction`

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_CommitTransaction(self, *args)

    def RollbackTransaction(self, *args):
        r"""
        RollbackTransaction(Layer self) -> OGRErr

        Roll back a datasource to its state before the start of the current transaction.

        For more details: :cpp:func:`OGR_L_RollbackTransaction`

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success.

        """
        return _ogr.Layer_RollbackTransaction(self, *args)

    def FindFieldIndex(self, *args):
        r"""
        FindFieldIndex(Layer self, char const * pszFieldName, int bExactMatch) -> int

        Find the index of field in a layer.

        For more details: :cpp:func:`OGR_L_FindFieldIndex`

        Returns
        --------
        int:
            field index, or -1 if the field doesn't exist

        """
        return _ogr.Layer_FindFieldIndex(self, *args)

    def GetSpatialRef(self, *args):
        r"""
        GetSpatialRef(Layer self) -> SpatialReference

        Fetch the spatial reference system for this layer.

        For more details: :cpp:func:`OGR_L_GetSpatialRef`

        Returns
        --------
        SpatialReference:
            spatial reference, or None if there isn't one.

        """
        return _ogr.Layer_GetSpatialRef(self, *args)

    def GetFeaturesRead(self, *args):
        r"""
        GetFeaturesRead(Layer self) -> GIntBig

        For more details: :cpp:func:`OGR_L_GetFeaturesRead`

        """
        return _ogr.Layer_GetFeaturesRead(self, *args)

    def SetIgnoredFields(self, *args):
        r"""
        SetIgnoredFields(Layer self, char const ** options) -> OGRErr

        Set which fields can be omitted when retrieving features from the
        layer.

        For more details: :cpp:func:`OGR_L_SetIgnoredFields`

        Parameters
        -----------
        options: list[str]
            A list of field names.
            If an empty list is passed, the ignored list is cleared.

        Returns
        -------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` if all field names have been resolved
            (even if the driver does not support this method)

        """
        return _ogr.Layer_SetIgnoredFields(self, *args)

    def Intersection(self, *args, **kwargs):
        r"""
        Intersection(Layer self, Layer method_layer, Layer result_layer, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> OGRErr

        Intersection of two layers.

        For more details: :cpp:func:`OGR_L_Intersection`

        Parameters
        -----------
        method_layer: Layer
            the method layer. Should not be None.
        result_layer: Layer
            the layer where the features resulting from the
            operation are inserted. Should not be None.
        options: list[str], optional
            List of options (empty list is allowed). For example ["PROMOTE_TO_MULTI=YES"].
        callback: Callable, optional
            a GDALProgressFunc() compatible callback function for
            reporting progress or None.
        callback_data:
            Argument to be passed to 'callback'. May be None.

        Returns
        -------
        int:
            An error code if there was an error or the execution was interrupted,
            :py:const:`osgeo.ogr.OGRERR_NONE` otherwise.

        """
        return _ogr.Layer_Intersection(self, *args, **kwargs)

    def Union(self, *args, **kwargs):
        r"""
        Union(Layer self, Layer method_layer, Layer result_layer, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> OGRErr

        Union of two layers.

        For more details: :cpp:func:`OGR_L_Union`

        The first geometry field is always used.

        Parameters
        -----------
        method_layer: Layer
            the method layer. Should not be None.
        result_layer: Layer
            the layer where the features resulting from the
            operation are inserted. Should not be None.
        options: list[str], optional
            List of options (empty list is allowed). For example ["PROMOTE_TO_MULTI=YES"].
        callback: Callable, optional
            a GDALProgressFunc() compatible callback function for
            reporting progress or None.
        callback_data:
            Argument to be passed to 'callback'. May be None.

        Returns
        -------
        int:
            An error code if there was an error or the execution was interrupted,
            :py:const:`osgeo.ogr.OGRERR_NONE` otherwise.

        """
        return _ogr.Layer_Union(self, *args, **kwargs)

    def SymDifference(self, *args, **kwargs):
        r"""
        SymDifference(Layer self, Layer method_layer, Layer result_layer, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> OGRErr

        Symmetrical difference of two layers.

        For more details: :cpp:func:`OGR_L_SymDifference`

        Parameters
        -----------
        method_layer: Layer
            the method layer. Should not be None.
        result_layer: Layer
            the layer where the features resulting from the
            operation are inserted. Should not be None.
        options: list[str], optional
            List of options (empty list is allowed). For example ["PROMOTE_TO_MULTI=YES"].
        callback: Callable, optional
            a GDALProgressFunc() compatible callback function for
            reporting progress or None.
        callback_data:
            Argument to be passed to 'callback'. May be None.

        Returns
        -------
        int:
            An error code if there was an error or the execution was interrupted,
            :py:const:`osgeo.ogr.OGRERR_NONE` otherwise.

        """
        return _ogr.Layer_SymDifference(self, *args, **kwargs)

    def Identity(self, *args, **kwargs):
        r"""
        Identity(Layer self, Layer method_layer, Layer result_layer, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> OGRErr

        Identify the features of this layer with the ones from the identity layer.

        For more details: :cpp:func:`OGR_L_Identity`

        Parameters
        -----------
        method_layer: Layer
            the method layer. Should not be None.
        result_layer: Layer
            the layer where the features resulting from the
            operation are inserted. Should not be None.
        options: list[str], optional
            List of options (empty list is allowed). For example ["PROMOTE_TO_MULTI=YES"].
        callback: Callable, optional
            a GDALProgressFunc() compatible callback function for
            reporting progress or None.
        callback_data:
            Argument to be passed to 'callback'. May be None.

        Returns
        -------
        int:
            An error code if there was an error or the execution was interrupted,
            :py:const:`osgeo.ogr.OGRERR_NONE` otherwise.

        """
        return _ogr.Layer_Identity(self, *args, **kwargs)

    def Update(self, *args, **kwargs):
        r"""
        Update(Layer self, Layer method_layer, Layer result_layer, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> OGRErr

        Update this layer with features from the update layer.

        For more details: :cpp:func:`OGR_L_Update`

        Parameters
        -----------
        method_layer: Layer
            the method layer. Should not be None.
        result_layer: Layer
            the layer where the features resulting from the
            operation are inserted. Should not be None.
        options: list[str], optional
            List of options (empty list is allowed). For example ["PROMOTE_TO_MULTI=YES"].
        callback: Callable, optional
            a GDALProgressFunc() compatible callback function for
            reporting progress or None.
        callback_data:
            Argument to be passed to 'callback'. May be None.

        Returns
        -------
        int:
            An error code if there was an error or the execution was interrupted,
            :py:const:`osgeo.ogr.OGRERR_NONE` otherwise.

        """
        return _ogr.Layer_Update(self, *args, **kwargs)

    def Clip(self, *args, **kwargs):
        r"""
        Clip(Layer self, Layer method_layer, Layer result_layer, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> OGRErr

        Clip off areas that are not covered by the method layer.

        For more details: :cpp:func:`OGR_L_Clip`

        Parameters
        -----------
        method_layer: Layer
            the method layer. Should not be None.
        result_layer: Layer
            the layer where the features resulting from the
            operation are inserted. Should not be None.
        options: list[str], optional
            List of options (empty list is allowed). For example ["PROMOTE_TO_MULTI=YES"].
        callback: Callable, optional
            a GDALProgressFunc() compatible callback function for
            reporting progress or None.
        callback_data:
            Argument to be passed to 'callback'. May be None.

        Returns
        -------
        int:
            An error code if there was an error or the execution was interrupted,
            :py:const:`osgeo.ogr.OGRERR_NONE` otherwise.

        """
        return _ogr.Layer_Clip(self, *args, **kwargs)

    def Erase(self, *args, **kwargs):
        r"""
        Erase(Layer self, Layer method_layer, Layer result_layer, char ** options=None, GDALProgressFunc callback=0, void * callback_data=None) -> OGRErr

        Remove areas that are covered by the method layer.

        For more details: :cpp:func:`OGR_L_Erase`

        Parameters
        -----------
        method_layer: Layer
            the method layer. Should not be None.
        result_layer: Layer
            the layer where the features resulting from the
            operation are inserted. Should not be None.
        options: list[str], optional
            List of options (empty list is allowed). For example ["PROMOTE_TO_MULTI=YES"].
        callback: Callable, optional
            a GDALProgressFunc() compatible callback function for
            reporting progress or None.
        callback_data:
            Argument to be passed to 'callback'. May be None.

        Returns
        -------
        int:
            An error code if there was an error or the execution was interrupted,
            :py:const:`osgeo.ogr.OGRERR_NONE` otherwise.

        """
        return _ogr.Layer_Erase(self, *args, **kwargs)

    def GetStyleTable(self, *args):
        r"""
        GetStyleTable(Layer self) -> StyleTable

        Get style table.

        For more details: :cpp:func:`OGR_L_GetStyleTable`

        """
        return _ogr.Layer_GetStyleTable(self, *args)

    def SetStyleTable(self, *args):
        r"""
        SetStyleTable(Layer self, StyleTable table)

        Set style table.

        For more details: :cpp:func:`OGR_L_SetStyleTable`

        """
        return _ogr.Layer_SetStyleTable(self, *args)

    def ExportArrowArrayStreamPyCapsule(self, *args):
        r"""ExportArrowArrayStreamPyCapsule(Layer self, char ** options=None) -> PyObject *"""
        return _ogr.Layer_ExportArrowArrayStreamPyCapsule(self, *args)

    def GetArrowStream(self, *args):
        r"""GetArrowStream(Layer self, char ** options=None) -> ArrowArrayStream"""
        return _ogr.Layer_GetArrowStream(self, *args)

    def IsArrowSchemaSupported(self, *args):
        r"""IsArrowSchemaSupported(Layer self, ArrowSchema schema, char ** options=None)"""
        return _ogr.Layer_IsArrowSchemaSupported(self, *args)

    def CreateFieldFromArrowSchema(self, *args):
        r"""CreateFieldFromArrowSchema(Layer self, ArrowSchema schema, char ** options=None) -> OGRErr"""
        return _ogr.Layer_CreateFieldFromArrowSchema(self, *args)

    def WriteArrowBatch(self, *args):
        r"""WriteArrowBatch(Layer self, ArrowSchema schema, ArrowArray array, char ** options=None) -> OGRErr"""
        return _ogr.Layer_WriteArrowBatch(self, *args)

    def WriteArrowStreamCapsule(self, *args):
        r"""WriteArrowStreamCapsule(Layer self, PyObject * capsule, int createFieldsFromSchema, char ** options=None) -> OGRErr"""
        return _ogr.Layer_WriteArrowStreamCapsule(self, *args)

    def WriteArrowSchemaAndArrowArrayCapsule(self, *args):
        r"""WriteArrowSchemaAndArrowArrayCapsule(Layer self, PyObject * schemaCapsule, PyObject * arrayCapsule, int createFieldsFromSchema, char ** options=None) -> OGRErr"""
        return _ogr.Layer_WriteArrowSchemaAndArrowArrayCapsule(self, *args)

    def GetGeometryTypes(self, *args, **kwargs):
        r"""
        GetGeometryTypes(Layer self, int geom_field=0, int flags=0, GDALProgressFunc callback=0, void * callback_data=None)

        Get actual geometry types found in features.

        For more details: :cpp:func:`OGR_L_GetGeometryTypes`

        Parameters
        -----------
        geom_field: int, optional
            index of the geometry field
        flags: int, optional
            0, or a combination of :py:const:`osgeo.ogr.GGT_COUNT_NOT_NEEDED`,
            :py:const:`osgeo.ogr.GGT_STOP_IF_MIXED` and
            :py:const:`osgeo.ogr.GGT_GEOMCOLLECTIONZ_TINZ`
        callback: Callable, optional
            a GDALProgressFunc() compatible callback function for
            cancellation or None.
        callback_data:
            Argument to be passed to 'callback'. May be None.

        Returns
        -------
        dict:
            A dictionary whose keys are :py:const:`osgeo.ogr.wkbXXXX` constants and
            values the corresponding number of geometries of that type in the layer.

        """
        return _ogr.Layer_GetGeometryTypes(self, *args, **kwargs)

    def GetSupportedSRSList(self, *args, **kwargs):
        r"""GetSupportedSRSList(Layer self, int geom_field=0)"""
        return _ogr.Layer_GetSupportedSRSList(self, *args, **kwargs)

    def SetActiveSRS(self, *args):
        r"""SetActiveSRS(Layer self, int geom_field, SpatialReference srs) -> OGRErr"""
        return _ogr.Layer_SetActiveSRS(self, *args)

    def Reference(self):
      "For backwards compatibility only."
      pass

    def Dereference(self):
      "For backwards compatibility only."
      pass

    def __len__(self):
        """Returns the number of features in the layer"""
        return self.GetFeatureCount()

    # To avoid __len__ being called when testing boolean value
    # which can have side effects (#4758)
    def __nonzero__(self):
        return True

    # For Python 3 compat
    __bool__ = __nonzero__

    def __getitem__(self, value):
        """Support list and slice -like access to the layer.
        layer[0] would return the first feature on the layer.
        layer[0:4] would return a list of the first four features."""
        if isinstance(value, slice):
            import sys
            output = []
            if value.stop == sys.maxsize:
    #for an unending slice, sys.maxsize is used
    #We need to stop before that or GDAL will write an
    ##error to stdout
                stop = len(self) - 1
            else:
                stop = value.stop
            for i in range(value.start, stop, value.step):
                feature = self.GetFeature(i)
                if feature:
                    output.append(feature)
                else:
                    return output
            return output
        if isinstance(value, int):
            if value > len(self) - 1:
                raise IndexError
            return self.GetFeature(value)
        else:
            raise TypeError("Input %s is not of IntType or SliceType" % type(value))

    def CreateFields(self, fields):
        """Create a list of fields on the Layer"""
        for i in fields:
            self.CreateField(i)

    def __enter__(self):
        """Method called when using Dataset.ExecuteSQL() as a context manager"""
        if hasattr(self, "_dataset_weak_ref"):
            self._dataset_strong_ref = self._dataset_weak_ref()
            assert self._dataset_strong_ref is not None
            del self._dataset_weak_ref
            return self
        raise Exception("__enter__() called in unexpected situation")

    def __exit__(self, *args):
        """Method called when using Dataset.ExecuteSQL() as a context manager"""
        if hasattr(self, "_dataset_strong_ref"):
            self._dataset_strong_ref.ReleaseResultSet(self)
            del self._dataset_strong_ref

    def __iter__(self):
        self.ResetReading()
        while True:
            feature = self.GetNextFeature()
            if not feature:
                break
            yield feature

    def schema(self):
        output = []
        defn = self.GetLayerDefn()
        for n in range(defn.GetFieldCount()):
            output.append(defn.GetFieldDefn(n))
        return output
    schema = property(schema)


    def __arrow_c_stream__(self, requested_schema=None):
        """
        Export to a C ArrowArrayStream PyCapsule, according to
        https://arrow.apache.org/docs/format/CDataInterface/PyCapsuleInterface.html

        Also note that only one active stream can be queried at a time for a
        given layer.

        To specify options how the ArrowStream should be generated, use
        the GetArrowArrayStreamInterface(self, options) method

        Parameters
        ----------
        requested_schema : PyCapsule, default None
            The schema to which the stream should be casted, passed as a
            PyCapsule containing a C ArrowSchema representation of the
            requested schema.
            Currently, this is not supported and will raise a
            NotImplementedError if the schema is not None

        Returns
        -------
        PyCapsule
            A capsule containing a C ArrowArrayStream struct.
        """

        if requested_schema is not None:
            raise NotImplementedError("requested_schema != None not implemented")

        return self.ExportArrowArrayStreamPyCapsule()


    def GetArrowArrayStreamInterface(self, options = []):
        """
        Return a proxy object that implements the __arrow_c_stream__() method,
        but allows the user to pass options.

        Parameters
        ----------
        options : List of strings or dict with options such as INCLUDE_FID=NO, MAX_FEATURES_IN_BATCH=<number>, etc.

        Returns
        -------
        a proxy object which implements the __arrow_c_stream__() method
        """

        class ArrowArrayStreamInterface:
            def __init__(self, lyr, options):
                self.lyr = lyr
                self.options = options

            def __arrow_c_stream__(self, requested_schema=None):
                """
                Export to a C ArrowArrayStream PyCapsule, according to
                https://arrow.apache.org/docs/format/CDataInterface/PyCapsuleInterface.html

                Also note that only one active stream can be queried at a time for a
                given layer.

                To specify options how the ArrowStream should be generated, use
                the GetArrowArrayStreamInterface(self, options) method

                Parameters
                ----------
                requested_schema : PyCapsule, default None
                    The schema to which the stream should be casted, passed as a
                    PyCapsule containing a C ArrowSchema representation of the
                    requested schema.
                    Currently, this is not supported and will raise a
                    NotImplementedError if the schema is not None

                Returns
                -------
                PyCapsule
                    A capsule containing a C ArrowArrayStream struct.
                """
                if requested_schema is not None:
                    raise NotImplementedError("requested_schema != None not implemented")

                return self.lyr.ExportArrowArrayStreamPyCapsule(self.options)

        return ArrowArrayStreamInterface(self, options)


    def GetArrowStreamAsPyArrow(self, options = []):
        """ Return an ArrowStream as PyArrow Schema and Array objects """

        import pyarrow as pa

        class Stream:
            def __init__(self, stream):
                self.stream = stream
                self.end_of_stream = False

            def schema(self):
                """ Return the schema as a PyArrow DataType """

                schema = self.stream.GetSchema()
                if schema is None:
                    raise Exception("cannot get schema")
                return pa.DataType._import_from_c(schema._getPtr())

            schema = property(schema)

            def __enter__(self):
                return self

            def __exit__(self, type, value, tb):
                self.end_of_stream = True
                self.stream = None

            def GetNextRecordBatch(self):
                """ Return the next RecordBatch as a PyArrow StructArray, or None at end of iteration """

                array = self.stream.GetNextRecordBatch()
                if array is None:
                    return None
                return pa.Array._import_from_c(array._getPtr(), self.schema)

            def __iter__(self):
                """ Return an iterator over record batches as a PyArrow StructArray """
                if self.end_of_stream:
                    raise Exception("Stream has already been iterated over")

                while True:
                    batch = self.GetNextRecordBatch()
                    if not batch:
                        break
                    yield batch
                self.end_of_stream = True
                self.stream = None

        stream = self.GetArrowStream(options)
        if not stream:
            raise Exception("GetArrowStream() failed")
        return Stream(stream)


    def GetArrowStreamAsNumPy(self, options = []):
        """ Return an ArrowStream as NumPy Array objects.
            A specific option to this method is USE_MASKED_ARRAYS=YES/NO (default is YES).
        """

        from osgeo import gdal_array

        class Stream:
            def __init__(self, stream, use_masked_arrays):
                self.stream = stream
                self.schema = stream.GetSchema()
                self.end_of_stream = False
                self.use_masked_arrays = use_masked_arrays

            def __enter__(self):
                return self

            def __exit__(self, type, value, tb):
                self.end_of_stream = True
                self.schema = None
                self.stream = None

            def GetNextRecordBatch(self):
                """ Return the next RecordBatch as a dictionary of Numpy arrays, or None at end of iteration """

                array = self.stream.GetNextRecordBatch()
                if array is None:
                    return None

                ret = gdal_array._RecordBatchAsNumpy(array._getPtr(),
                                                     self.schema._getPtr(),
                                                     array)
                if ret is None:
                    gdal_array._RaiseException()
                    return ret
                for key, val in ret.items():
                    if isinstance(val, dict):
                        if self.use_masked_arrays:
                            import numpy.ma as ma
                            ret[key] = ma.masked_array(val["data"], val["mask"])
                        else:
                            ret[key] = val["data"]
                return ret

            def __iter__(self):
                """ Return an iterator over record batches as a dictionary of Numpy arrays """

                if self.end_of_stream:
                    raise Exception("Stream has already been iterated over")

                try:
                    while True:
                        batch = self.GetNextRecordBatch()
                        if not batch:
                            break
                        yield batch
                finally:
                    self.end_of_stream = True
                    self.stream = None

        stream = self.GetArrowStream(options)
        if not stream:
            raise Exception("GetArrowStream() failed")

        use_masked_arrays = True
        for opt in options:
            opt = opt.upper()
            if opt.startswith('USE_MASKED_ARRAYS='):
                use_masked_arrays = opt[len('USE_MASKED_ARRAYS='):] in ('YES', 'TRUE', 'ON', '1')

        return Stream(stream, use_masked_arrays)


    def IsPyArrowSchemaSupported(self, pa_schema, options=[]):
        """Returns whether the passed pyarrow Schema is supported by the layer, as a tuple (success: bool, errorMsg: str).

           This may be used as a preliminary check before calling WritePyArrowBatch()
        """

        import pyarrow as pa
        schema = ArrowSchema()
        pa_schema._export_to_c(schema._getPtr())
        return self.IsArrowSchemaSupported(schema, options)


    def CreateFieldFromPyArrowSchema(self, pa_schema, options=[]):
        """Create a field from the passed pyarrow Schema."""

        import pyarrow as pa
        schema = ArrowSchema()
        pa_schema._export_to_c(schema._getPtr())
        return self.CreateFieldFromArrowSchema(schema, options)


    def WriteArrow(self, obj, requested_schema=None, createFieldsFromSchema=None, options=[]):
        """Write the content of the passed object, which must implement the
           __arrow_c_stream__ or __arrow_c_array__ interface, into the layer.

           Parameters
           ----------
           obj:
               Object implementing the __arrow_c_stream__ or __arrow_c_array__ interface

           requested_schema: PyCapsule, object implementing __arrow_c_schema__ or None. Default None
               The schema to which the stream should be casted, passed as a
               PyCapsule containing a C ArrowSchema representation of the
               requested schema, or an object implementing the __arrow_c_schema__ interface.

           createFieldsFromSchema: boolean or None. Default to None
               Whether OGRLayer::CreateFieldFromArrowSchema() should be called. If None
               specified, it is called if no fields have been created yet

           options: list of strings
               Options to pass to OGRLayer::CreateFieldFromArrowSchema() and OGRLayer::WriteArrowBatch()

        """

        if createFieldsFromSchema is None:
            createFieldsFromSchema = -1
        elif createFieldsFromSchema is True:
            createFieldsFromSchema = 1
        else:
            createFieldsFromSchema = 0

        if requested_schema is not None and hasattr(requested_schema, "__arrow_c_schema__"):
            requested_schema = requested_schema.__arrow_c_schema__()

        if hasattr(obj, "__arrow_c_stream__"):
            stream_capsule = obj.__arrow_c_stream__(requested_schema=requested_schema)
            return self.WriteArrowStreamCapsule(stream_capsule, createFieldsFromSchema, options)

        if hasattr(obj, "__arrow_c_array__"):
            schema_capsule, array_capsule = obj.__arrow_c_array__(requested_schema=requested_schema)
            return self.WriteArrowSchemaAndArrowArrayCapsule(schema_capsule, array_capsule, createFieldsFromSchema, options)

        raise Exception("Passed object does not implement the __arrow_c_stream__ or __arrow_c_array__ interface.")


    def WritePyArrow(self, pa_batch, options=[]):
        """Write the content of the passed PyArrow batch (either a pyarrow.Table, a pyarrow.RecordBatch or a pyarrow.StructArray) into the layer.

           See also the WriteArrow() method to be independent of PyArrow
        """

        import pyarrow as pa

    # Is it a pyarrow.Table ?
        if hasattr(pa_batch, "to_batches"):
            for batch in pa_batch.to_batches():
                if self.WritePyArrow(batch, options=options) != OGRERR_NONE:
                    return OGRERR_FAILURE
            return OGRERR_NONE

    # Is it a pyarrow.RecordBatch ?
        if hasattr(pa_batch, "columns") and hasattr(pa_batch, "schema"):
            array = pa.StructArray.from_arrays(pa_batch.columns, names=pa_batch.schema.names)
            return self.WritePyArrow(array, options=options)

    # Assume it is a pyarrow.StructArray
        schema = ArrowSchema()
        array = ArrowArray()
        pa_batch._export_to_c(array._getPtr(), schema._getPtr())
        return self.WriteArrowBatch(schema, array, options)



# Register Layer in _ogr:
_ogr.Layer_swigregister(Layer)
class Feature(object):
    r"""

    Python proxy of an :cpp:class:`OGRFeature`.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_Feature

    def __init__(self, *args, **kwargs):
        r"""
        __init__(Feature self, FeatureDefn feature_def) -> Feature


        Parameters
        -----------
        feature_def:
            :py:class:`FeatureDefn` to which the feature will adhere.

        """
        _ogr.Feature_swiginit(self, _ogr.new_Feature(*args, **kwargs))

    def GetDefnRef(self, *args):
        r"""
        GetDefnRef(Feature self) -> FeatureDefn


        Fetch the :py:class:`FeatureDefn` associated with this Feature.

        See :cpp:func:`OGRFeature::GetDefnRef()`.

        Returns
        --------
        FeatureDefn

        """
        return _ogr.Feature_GetDefnRef(self, *args)

    def SetGeometry(self, *args):
        r"""
        SetGeometry(Feature self, Geometry geom) -> OGRErr


        Set feature geometry.

        This function updates the features geometry, and operates exactly as
        :py:meth:`SetGeometryDirectly`, except that this function does not assume
        ownership of the passed geometry, but instead makes a copy of it.

        See :cpp:func:`OGRFeature::SetGeometry`.

        This method has only an effect on the in-memory feature object. If
        this object comes from a layer and the modifications must be
        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
        used afterwards.

        Parameters
        -----------
        geom : Geometry
            new geometry to apply to feature.

        Returns
        --------
        int:
            :py:const:`OGRERR_NONE` if successful, or
            :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for
            the :py:class:`FeatureDefn` (checking not yet implemented).

        """
        return _ogr.Feature_SetGeometry(self, *args)

    def SetGeometryDirectly(self, geom):
        """
        Set feature geometry.

        This function updates the features geometry, and operates exactly as
        :py:meth:`SetGeometry`, except that this function assumes ownership of the
        passed geometry (even in case of failure of that function).

        See :cpp:func:`OGRFeature::SetGeometryDirectly`.

        This method has only an effect on the in-memory feature object. If
        this object comes from a layer and the modifications must be
        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
        used afterwards.

        Parameters
        -----------
        geom : Geometry
            geometry to apply to feature.

        Returns
        --------
        int:
            :py:const:`OGRERR_NONE` if successful, or
            :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for
            the :py:class:`FeatureDefn` (checking not yet implemented).
        """
        ret = _ogr.Feature_SetGeometryDirectly(self, geom)
        if ret == OGRERR_NONE:
            self._add_geom_ref(geom)
        return ret



    def GetGeometryRef(self, *args):
        r"""
        GetGeometryRef(Feature self) -> Geometry

        Return the feature geometry

        The lifetime of the returned geometry is bound to the one of its belonging
        feature.

        See :cpp:func:`OGRFeature::GetGeometryRef`

        The :py:func:`Feature.geometry` method is also available as an alias of :py:func:`Feature.GetGeometryRef`.

        Returns
        --------
        Geometry:
            the geometry, or None.

        """
        val = _ogr.Feature_GetGeometryRef(self, *args)

        self._add_geom_ref(val)


        return val


    def SetGeomField(self, *args):
        r"""
        SetGeomField(Feature self, int iField, Geometry geom) -> OGRErr
        SetGeomField(Feature self, char const * field_name, Geometry geom) -> OGRErr


        Set feature geometry of a specified geometry field.

        This function updates the features geometry, and operates exactly as
        :py:meth:`SetGeomFieldDirectly`, except that this function does not assume
        ownership of the passed geometry, but instead makes a copy of it.

        See :cpp:func:`OGRFeature::SetGeomField`.

        Parameters
        -----------
        fld_index : int / str
            Geometry field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.
        geom : Geometry
            handle to the new geometry to apply to feature.

        Returns
        --------
        int:
            :py:const:`OGRERR_NONE` if successful, or
            :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for
            the :py:class:`FeatureDefn` (checking not yet implemented).

        """
        return _ogr.Feature_SetGeomField(self, *args)

    def SetGeomFieldDirectly(self, field, geom):
        """
        Set feature geometry of a specified geometry field.

        This function updates the features geometry, and operates exactly as
        :py:meth:`SetGeomField`, except that this function assumes ownership of the
        passed geometry (even in case of failure of that function).

        See :cpp:func:`OGRFeature::SetGeomFieldDirectly`.

        Parameters
        -----------
        fld_index : int / str
            Geometry field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.
        geom : Geometry
            handle to the new geometry to apply to feature.

        Returns
        --------
        int:
            :py:const:`OGRERR_NONE` if successful, or
            :py:const:`OGR_UNSUPPORTED_GEOMETRY_TYPE` if the geometry type is illegal for
            the :py:class:`FeatureDefn` (checking not yet implemented).
        """
        ret = _ogr.Feature_SetGeomFieldDirectly(self, field, geom)
        if ret == OGRERR_NONE:
            self._add_geom_ref(geom)
        return ret



    def GetGeomFieldRef(self, *args):
        r"""
        GetGeomFieldRef(Feature self, int iField) -> Geometry
        GetGeomFieldRef(Feature self, char const * field_name) -> Geometry


        Fetch a feature :py:class:`Geometry`.

        See :cpp:func:`OGRFeature::GetGeomFieldRef`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        -------
        Geometry


        """
        val = _ogr.Feature_GetGeomFieldRef(self, *args)

        self._add_geom_ref(val)


        return val


    def Clone(self, *args):
        r"""
        Clone(Feature self) -> Feature

        Duplicate a Feature.
        See :cpp:func:`OGRFeature::Clone`.

        Returns
        --------
        Feature

        """
        return _ogr.Feature_Clone(self, *args)

    def Equal(self, *args):
        r"""
        Equal(Feature self, Feature feature) -> bool


        Test if two features are the same.

        Two features are considered equal if they reference the
        same :py:class:`FeatureDefn`, have the same field values, and the same geometry
        (as tested by :py:func:`Geometry.Equal`) as well as the same feature id.

        See :cpp:func:`OGRFeature::Equal`.

        Parameters
        -----------
        feature : Feature
            feature to test this one against

        Returns
        --------
        bool

        """
        return _ogr.Feature_Equal(self, *args)

    def GetFieldCount(self, *args):
        r"""
        GetFieldCount(Feature self) -> int


        Fetch number of fields on this feature This will always be the same as
        the field count for the :py:class:`FeatureDefn`.

        See :cpp:func:`OGRFeature::GetFieldCount`.

        Returns
        --------
        int:
            count of fields.

        """
        return _ogr.Feature_GetFieldCount(self, *args)

    def GetFieldDefnRef(self, *args):
        r"""
        GetFieldDefnRef(Feature self, int id) -> FieldDefn
        GetFieldDefnRef(Feature self, char const * field_name) -> FieldDefn


        Fetch definition for this field.

        See :cpp:func:`OGRFeature::GetFieldDefnRef`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        FieldDefn
            a reference to the field definition. This reference should
            not be modified.

        """
        return _ogr.Feature_GetFieldDefnRef(self, *args)

    def GetGeomFieldCount(self, *args):
        r"""
        GetGeomFieldCount(Feature self) -> int


        Fetch number of geometry fields on this feature This will always be
        the same as the geometry field count for the :py:class:`FeatureDefn`.

        See :cpp:func:`OGRFeature::GetGeomFieldCount`.

        Returns
        --------
        int:
            count of geometry fields.

        """
        return _ogr.Feature_GetGeomFieldCount(self, *args)

    def GetGeomFieldDefnRef(self, *args):
        r"""
        GetGeomFieldDefnRef(Feature self, int id) -> GeomFieldDefn
        GetGeomFieldDefnRef(Feature self, char const * field_name) -> GeomFieldDefn


        Fetch definition for this geometry field.

        See :cpp:func:`OGRFeature::GetGeomFieldDefnRef`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        GeomFieldDefn:
            a reference to the field definition.
            Should not be deleted or modified.

        """
        return _ogr.Feature_GetGeomFieldDefnRef(self, *args)

    def GetFieldAsString(self, *args):
        r"""
        GetFieldAsString(Feature self, int id) -> char const
        GetFieldAsString(Feature self, char const * field_name) -> char const *


        :py:const:`OFTReal` and :py:const:`OFTInteger` fields will be translated to string using
        sprintf(), but not necessarily using the established formatting rules.
        Other field types, or errors will result in a return value of zero.

        See :cpp:func:`OGRFeature::GetFieldAsString`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        str:
            the field value.

        """
        return _ogr.Feature_GetFieldAsString(self, *args)

    def GetFieldAsISO8601DateTime(self, *args):
        r"""
        GetFieldAsISO8601DateTime(Feature self, int id, char ** options=None) -> char const
        GetFieldAsISO8601DateTime(Feature self, char const * field_name, char ** options=None) -> char const *


        Fetch :py:const:`OFTDateTime` field value as a ISO8601 representation.

        Return a string like 'YYYY-MM-DDTHH:MM:SS(.sss)?(Z|([+|-]HH:MM))?'
        Milliseconds are omitted if equal to zero.
        Other field types, or errors will result in a return of an empty string.

        See :cpp:func:`OGRFeature::GetFieldAsISO8601DateTime`.

        .. versionadded:: 3.7

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.
        options : dict / str
            Not currently used.

        """
        return _ogr.Feature_GetFieldAsISO8601DateTime(self, *args)

    def GetFieldAsInteger(self, *args):
        r"""
        GetFieldAsInteger(Feature self, int id) -> int
        GetFieldAsInteger(Feature self, char const * field_name) -> int


        Fetch field value as a 32-bit integer.

        :py:const:`OFTString` features will be translated using atoi().
        :py:const:`OFTReal` fields will be cast to integer. Other field types, or
        errors will result in a return value of zero.

        See :cpp:func:`GetFieldAsInteger`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        int:
            the field value.

        Examples
        --------
        >>> defn = ogr.FeatureDefn()
        >>> defn.AddFieldDefn(ogr.FieldDefn('my_int', ogr.OFTInteger64))
        >>> feature = ogr.Feature(defn)
        >>> feature['my_int'] = 2**32 + 1
        >>> feature.GetFieldAsInteger('my_int')
        Warning 1: Integer overflow occurred when trying to return 64bit integer. Use GetFieldAsInteger64() instead
        2147483647
        >>> feature.GetFieldAsInteger64('my_int')
        4294967297
        >>> feature.GetField('my_int')
        4294967297

        """
        return _ogr.Feature_GetFieldAsInteger(self, *args)

    def GetFieldAsInteger64(self, *args):
        r"""
        GetFieldAsInteger64(Feature self, int id) -> GIntBig
        GetFieldAsInteger64(Feature self, char const * field_name) -> GIntBig


        Fetch field value as integer 64 bit.

        :py:const:`OFTInteger` are promoted to 64 bit. :py:const:`OFTString` features
        will be translated using :cpp:func:`CPLAtoGIntBig`. :py:const:`OFTReal` fields
        will be cast to integer. Other field types, or errors will result in a return
        value of zero.

        See :cpp:func:`OGRFeature::GetFieldAsInteger64`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        int:
            the field value.

        """
        return _ogr.Feature_GetFieldAsInteger64(self, *args)

    def GetFieldAsDouble(self, *args):
        r"""
        GetFieldAsDouble(Feature self, int id) -> double
        GetFieldAsDouble(Feature self, char const * field_name) -> double

        Fetch field value as a double.

        :py:const:`OFTString` features will be translated using :cpp:func:`CPLAtof`. :py:const:`OFTInteger`
        fields will be cast to double. Other field types, or errors will
        result in a return value of zero.

        See :cpp:func:`OGRFeature::GetFieldAsDouble`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        float:
            the field value.

        """
        return _ogr.Feature_GetFieldAsDouble(self, *args)

    def GetFieldAsDateTime(self, *args):
        r"""
        GetFieldAsDateTime(Feature self, int id)
        GetFieldAsDateTime(Feature self, char const * field_name)


        Fetch field value as date and time.

        Currently this method only works for :py:const:`OFTDate`, :py:const:`OFTTime`
        and :py:const:`OFTDateTime` fields.

        See :cpp:func:`OGRFeature::GetFieldAsDateTime`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        list
            list containing [ year, month, day, hour, minute, second, timezone flag ]

        Examples
        --------
        >>> from datetime import datetime
        >>> from zoneinfo import ZoneInfo
        >>> defn = ogr.FeatureDefn()
        >>> defn.AddFieldDefn(ogr.FieldDefn('unknown', ogr.OFTDateTime))
        >>> defn.AddFieldDefn(ogr.FieldDefn('local', ogr.OFTDateTime))
        >>> defn.AddFieldDefn(ogr.FieldDefn('utc', ogr.OFTDateTime))
        >>> feature = ogr.Feature(defn)
        >>> feature['unknown'] = datetime.now()
        >>> feature['local'] = datetime.now(ZoneInfo('Canada/Eastern'))
        >>> feature['utc'] = datetime.now(ZoneInfo('UTC'))
        >>> feature.GetFieldAsDateTime('unknown')
        [2024, 3, 15, 20, 34, 52.594173431396484, 0]
        >>> feature.GetFieldAsDateTime('local')
        [2024, 3, 15, 20, 34, 52.59502410888672, 84]
        >>> feature.GetFieldAsDateTime('utc')
        [2024, 3, 16, 0, 34, 52.59580993652344, 100]

        See Also
        --------
        :py:func:`Feature.GetFieldAsISO8601DateTime`

        """
        return _ogr.Feature_GetFieldAsDateTime(self, *args)

    def GetFieldAsIntegerList(self, *args):
        r"""
        GetFieldAsIntegerList(Feature self, int id)
        GetFieldAsIntegerList(Feature self, char const * field_name)


        Fetch field value as a list of integers.

        Currently this function only works for :py:const:`OFTIntegerList` fields.

        This function is the same as the C++ method
        :cpp:func:`OGRFeature::GetFieldAsIntegerList`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        list:
            the field value.

        """
        return _ogr.Feature_GetFieldAsIntegerList(self, *args)

    def GetFieldAsInteger64List(self, *args):
        r"""
        GetFieldAsInteger64List(Feature self, int id)

        Fetch field value as a list of 64 bit integers.

        Currently this function only works for :py:const:`OFTInteger64List` fields.

        See :cpp:func:`OGRFeature::GetFieldAsInteger64List`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        list:
            the field value.

        """
        return _ogr.Feature_GetFieldAsInteger64List(self, *args)

    def GetFieldAsDoubleList(self, *args):
        r"""
        GetFieldAsDoubleList(Feature self, int id)
        GetFieldAsDoubleList(Feature self, char const * field_name)


        Fetch field value as a list of doubles.

        Currently this function only works for :py:const:`OFTRealList` fields.

        See :cpp:func:`OGRFeature::GetFieldAsDoubleList`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        -------
        list

        Examples
        --------
        >>> defn = ogr.FeatureDefn()
        >>> defn.AddFieldDefn(ogr.FieldDefn('list', ogr.OFTRealList))
        >>> feature = ogr.Feature(defn)
        >>> feature['list'] = [1.1, 2.2, 3.3]
        >>> feature.GetFieldAsDoubleList('list')
        [1.1, 2.2, 3.3]

        """
        return _ogr.Feature_GetFieldAsDoubleList(self, *args)

    def GetFieldAsStringList(self, *args):
        r"""
        GetFieldAsStringList(Feature self, int id) -> char **


        Fetch field value as a list of strings.

        Currently this method only works for :py:const:`OFTStringList` fields.

        See :cpp:func:`OGRFeature::GetFieldAsStringList`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        list:
            the field value.

        """
        return _ogr.Feature_GetFieldAsStringList(self, *args)

    def GetFieldAsBinary(self, *args):
        r"""
        GetFieldAsBinary(Feature self, int id) -> OGRErr
        GetFieldAsBinary(Feature self, char const * field_name) -> OGRErr


        Fetch field value as binary.

        This method only works for :py:const:`OFTBinary` and :py:const:`OFTString` fields.

        See :cpp:func:`OGRFeature::GetFieldAsBinary`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        bytearray

        """
        return _ogr.Feature_GetFieldAsBinary(self, *args)

    def IsFieldSet(self, *args):
        r"""
        IsFieldSet(Feature self, int id) -> bool
        IsFieldSet(Feature self, char const * field_name) -> bool


        Test if a field has ever been assigned a value or not.

        See :cpp:func:`OGRFeature::IsFieldSet`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        bool:
            ``True`` if the field has been set, otherwise ``False``.

        """
        return _ogr.Feature_IsFieldSet(self, *args)

    def IsFieldNull(self, *args):
        r"""
        IsFieldNull(Feature self, int id) -> bool
        IsFieldNull(Feature self, char const * field_name) -> bool


        Test if a field is null.

        See :cpp:func:OGRFeature::`IsFieldNull`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        bool:
            ``True`` if the field is null, otherwise ``False``

        """
        return _ogr.Feature_IsFieldNull(self, *args)

    def IsFieldSetAndNotNull(self, *args):
        r"""
        IsFieldSetAndNotNull(Feature self, int id) -> bool
        IsFieldSetAndNotNull(Feature self, char const * field_name) -> bool


        Test if a field is set and not null.

        See :cpp:func:`OGRFeature::IsFieldSetAndNotNull`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        bool:
            ``True`` if the field is set and not null, otherwise ``False``.

        """
        return _ogr.Feature_IsFieldSetAndNotNull(self, *args)

    def GetFieldIndex(self, *args):
        r"""
        GetFieldIndex(Feature self, char const * field_name) -> int


        Fetch the field index given field name.

        See :cpp:func:`OGRFeature::GetFieldIndex`.

        Parameters
        -----------
        field_name:
            the name of the field to search for.

        Returns
        --------
        int:
            the field index, or -1 if no matching field is found.

        """
        return _ogr.Feature_GetFieldIndex(self, *args)

    def GetGeomFieldIndex(self, *args):
        r"""
        GetGeomFieldIndex(Feature self, char const * field_name) -> int


        Fetch the geometry field index given geometry field name.

        See :cpp:func:`OGRFeature::GetGeomFieldIndex`.

        Parameters
        -----------
        field_name:
            the name of the geometry field to search for.

        Returns
        --------
        int:
            the geometry field index, or -1 if no matching geometry field is found.

        """
        return _ogr.Feature_GetGeomFieldIndex(self, *args)

    def GetFID(self, *args):
        r"""
        GetFID(Feature self) -> GIntBig


        Get feature identifier.
        See :cpp:func:`OGRFeature::GetFID`

        Returns
        -------
        int:
            feature id or :py:const:`NullFID` if none has been assigned.

        """
        return _ogr.Feature_GetFID(self, *args)

    def SetFID(self, *args):
        r"""
        SetFID(Feature self, GIntBig fid) -> OGRErr


        Set the feature identifier.

        For specific types of features this operation may fail on illegal
        features ids. Generally it always succeeds. Feature ids should be
        greater than or equal to zero, with the exception of :py:const:NullFID` (-1)
        indicating that the feature id is unknown.

        See :cpp:func:`OGRFeature::SetFID`.

        Parameters
        -----------
        fid:
            the new feature identifier value to assign.

        Returns
        --------
        int:
            :py:const:`OGRERR_NONE` on success, or some other value on failure.

        """
        return _ogr.Feature_SetFID(self, *args)

    def DumpReadable(self, *args):
        r"""
        DumpReadable(Feature self)


        Print this feature in a human readable form.

        This dumps the attributes and geometry. It doesn't include
        definition information other than field types and names nor does it
        report the geometry spatial reference system.

        See :cpp:func:`OGRFeature::DumpReadable`.

        Examples
        --------
        >>> with gdal.OpenEx('data/poly.shp') as ds:
        ...     lyr = ds.GetLayer(0)
        ...     feature = lyr.GetNextFeature()
        ...     feature.DumpReadable()
        ...
        OGRFeature(poly):0
          AREA (Real) = 215229.266
          EAS_ID (Integer64) = 168
          PRFEDEA (String) = 35043411
          POLYGON ((479819.84375 4765180.5,479690.1875 4765259.5,479647.0 4765369.5,479730.375 4765400.5,480039.03125 4765539.5,480035.34375 4765558.5,480159.78125 4765610.5,480202.28125 4765482.0,480365.0 4765015.5,480389.6875 4764950.0,480133.96875 4764856.5,480080.28125 4764979.5,480082.96875 4765049.5,480088.8125 4765139.5,480059.90625 4765239.5,480019.71875 4765319.5,479980.21875 4765409.5,479909.875 4765370.0,479859.875 4765270.0,479819.84375 4765180.5))

        """
        return _ogr.Feature_DumpReadable(self, *args)

    def DumpReadableAsString(self, *args):
        r"""
        DumpReadableAsString(Feature self, char ** options=None) -> retStringAndCPLFree *


        Return feature information in a human-readable form.
        Returns the text printed by :py:func:`Feature.DumpReadable`.

        Returns
        -------
        str

        """
        return _ogr.Feature_DumpReadableAsString(self, *args)

    def UnsetField(self, *args):
        r"""
        UnsetField(Feature self, int id)
        UnsetField(Feature self, char const * field_name)


        Clear a field, marking it as unset.

        See :cpp:func:`OGRFeature::UnsetField`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        """
        return _ogr.Feature_UnsetField(self, *args)

    def SetFieldNull(self, *args):
        r"""
        SetFieldNull(Feature self, int id)
        SetFieldNull(Feature self, char const * field_name)


        Clear a field, marking it as null.

        See :cpp:func:`OGRFeature::SetFieldNull`.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.


        """
        return _ogr.Feature_SetFieldNull(self, *args)

    def SetFieldInteger64(self, *args):
        r"""SetFieldInteger64(Feature self, int id, GIntBig value)"""
        return _ogr.Feature_SetFieldInteger64(self, *args)

        # With several override, SWIG cannot dispatch automatically unicode strings
        # to the right implementation, so we have to do it at hand
    def SetField(self, *args) -> "OGRErr":
        """
        SetField(self, fld_index, value: str)
        SetField(self, fld_name, value: str)
        SetField(self, fld_index, value: int)
        SetField(self, fld_name, value: int)
        SetField(self, fld_index, value: float)
        SetField(self, fld_name, value: float)
        SetField(self, fld_index, year: int, month: int, day: int, hour: int, minute: int, second: int|float, tzflag: int)
        SetField(self, fld_name, year: int, month: int, day: int, hour: int, minute: int, second: int|float, tzflag: int)
        SetField(self, fld_index, value: bytes)
        SetField(self, fld_name, value: bytes)
        """

        if len(args) == 2 and args[1] is None:
            return _ogr.Feature_SetFieldNull(self, args[0])

        if len(args) == 2 and isinstance(args[1], int):
            fld_index = args[0]
            if isinstance(fld_index, str):
                fld_index = self._getfieldindex(fld_index)
            return _ogr.Feature_SetFieldInteger64(self, fld_index, args[1])

        if len(args) == 2 and isinstance(args[1], str):
            fld_index = args[0]
            if isinstance(fld_index, str):
                fld_index = self._getfieldindex(fld_index)
            return _ogr.Feature_SetFieldString(self, fld_index, args[1])

        if len(args) == 2 and isinstance(args[1], (bytes, bytearray, memoryview)):
            fld_index = args[0]
            if isinstance(fld_index, str):
                fld_index = self._getfieldindex(fld_index)
            if self.GetFieldType(fld_index) == OFTBinary:
                return self._SetFieldBinary(fld_index, args[1])

        return _ogr.Feature_SetField(self, *args)



    def SetFieldIntegerList(self, *args):
        r"""
        SetFieldIntegerList(Feature self, int id, int nList)
        void

        Set field to list of integer values.

        This function currently on has an effect of :py:const:`OFTIntegerList`,
        :py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.

        See :cpp:func:`OGRFeature::SetField`.

        This method has only an effect on the in-memory feature object. If
        this object comes from a layer and the modifications must be
        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
        used afterwards.

        Parameters
        -----------
        id : int
            the field to set, from 0 to :py:meth:`GetFieldCount`-1.
        nList : list
            the values to assign.

        """
        return _ogr.Feature_SetFieldIntegerList(self, *args)

    def SetFieldInteger64List(self, *args):
        r"""
        SetFieldInteger64List(Feature self, int id, int nList)
        void

        Set field to list of 64 bit integer values.

        This function currently on has an effect of :py:const:`OFTIntegerList`,
        :py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.

        See :cpp:func:`OGRFeature::SetField`.

        This method has only an effect on the in-memory feature object. If
        this object comes from a layer and the modifications must be
        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
        used afterwards.

        Parameters
        -----------
        id : int
            the field to set, from 0 to :py:meth:`GetFieldCount`-1.
        nList : list
            the values to assign.

        """
        return _ogr.Feature_SetFieldInteger64List(self, *args)

    def SetFieldDoubleList(self, *args):
        r"""
        SetFieldDoubleList(Feature self, int id, int nList)


        Set field to list of double values.

        This function currently on has an effect of :py:const:`OFTIntegerList`,
        :py:const:`OFTInteger64List`, :py:const:`OFTRealList` fields.

        See :cpp:func:`OGRFeature::SetField`.

        This method has only an effect on the in-memory feature object. If
        this object comes from a layer and the modifications must be
        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
        used afterwards.

        Parameters
        -----------
        id : int
            the field to set, from 0 to :py:meth:`GetFieldCount`-1.
        nList : list
            the values to assign.

        """
        return _ogr.Feature_SetFieldDoubleList(self, *args)

    def SetFieldStringList(self, *args):
        r"""
        SetFieldStringList(Feature self, int id, char ** pList)


        Set field to list of strings value.

        This function currently only has an effect of :py:const:`OFTStringList` fields.

        See :cpp:func:`OGRFeature::SetField`.

        This method has only an effect on the in-memory feature object. If
        this object comes from a layer and the modifications must be
        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
        used afterwards.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.
        value:
            the value to assign.

        """
        return _ogr.Feature_SetFieldStringList(self, *args)

    def _SetFieldBinary(self, *args):
        r"""_SetFieldBinary(Feature self, int id, int nLen)"""
        return _ogr.Feature__SetFieldBinary(self, *args)

    def SetFieldBinaryFromHexString(self, *args):
        r"""
        SetFieldBinaryFromHexString(Feature self, int id, char const * pszValue)
        SetFieldBinaryFromHexString(Feature self, char const * field_name, char const * pszValue)
        """
        return _ogr.Feature_SetFieldBinaryFromHexString(self, *args)

    def SetFrom(self, *args, **kwargs):
        r"""
        SetFrom(Feature self, Feature other, int forgiving=1) -> OGRErr

        Set one feature from another.

        Overwrite the contents of this feature from the geometry and
        attributes of another. The other feature does not need to have the
        same :py:class:`FeatureDefn`. Field values are copied by corresponding field
        names. Field types do not have to exactly match. OGR_F_SetField\*()
        function conversion rules will be applied as needed.

        See :cpp:func:`OGRFeature::SetFrom`.

        Parameters
        -----------
        other : Feature
            feature from which geometry and field values will be copied.
        forgiving : bool, default = True
            ``True`` if the operation should continue despite lacking
            output fields matching some of the source fields.

        Returns
        --------
        int:
            :py:const:`OGRERR_NONE` if the operation succeeds, even if some values are not
            transferred, otherwise an error code.

        """
        return _ogr.Feature_SetFrom(self, *args, **kwargs)

    def SetFromWithMap(self, *args):
        r"""
        SetFromWithMap(Feature self, Feature other, int forgiving, int nList) -> OGRErr


        Set one feature from another.

        Overwrite the contents of this feature from the geometry and
        attributes of another. The other feature does not need to have the
        same :py:class:`FeatureDefn`. Field values are copied according to the provided
        indices map. Field types do not have to exactly match.
        OGR_F_SetField\*() function conversion rules will be applied as needed.
        This is more efficient than :py:meth:SetFrom` in that this doesn't
        lookup the fields by their names. Particularly useful when the field
        names don't match.

        See :cpp:func:`OGRFeature::SetFrom`.

        Parameters
        -----------
        other : Feature
            handle to the feature from which geometry, and field
            values will be copied.
        forgiving : bool
            ``True`` if the operation should continue despite lacking
            output fields matching some of the source fields.
        nList : list
            Array of the indices of the destination feature's fields
            stored at the corresponding index of the source feature's fields. A
            value of -1 should be used to ignore the source's field. The array
            should not be NULL and be as long as the number of fields in the
            source feature.

        Returns
        --------
        OGRErr:
            :py:const:`OGRERR_NONE` if the operation succeeds, even if some values are not
            transferred, otherwise an error code.

        """
        return _ogr.Feature_SetFromWithMap(self, *args)

    def GetStyleString(self, *args):
        r"""
        GetStyleString(Feature self) -> char const *


        Fetch style string for this feature.

        Set the OGR Feature Style Specification for details on the format of
        this string, and :source_file:`ogr/ogr_featurestyle.h` for services available to parse
        it.

        See :cpp:func:`OGRFeature::GetStyleString`.

        Returns
        --------
        str or None

        """
        return _ogr.Feature_GetStyleString(self, *args)

    def SetStyleString(self, *args):
        r"""
        SetStyleString(Feature self, char const * the_string)


        Set feature style string.

        See :cpp:func:`OGRFeature::SetStyleString`.

        Parameters
        -----------
        the_string : str
            the style string to apply to this feature

        """
        return _ogr.Feature_SetStyleString(self, *args)

    def GetFieldType(self, *args):
        r"""
        GetFieldType(Feature self, int id) -> OGRFieldType
        GetFieldType(Feature self, char const * field_name) -> OGRFieldType


        Return the type of the given field.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        int
            field type code (e.g., :py:const:`OFTInteger`)

        """
        return _ogr.Feature_GetFieldType(self, *args)

    def Validate(self, *args):
        r"""
        Validate(Feature self, int flags=OGR_F_VAL_ALL, int bEmitError=TRUE) -> int


        Validate that a feature meets constraints of its schema.

        The scope of test is specified with the ``flags`` parameter.

        Regarding :py:const:`OGR_F_VAL_WIDTH`, the test is done assuming the string
        width must be interpreted as the number of UTF-8 characters. Some drivers might
        interpret the width as the number of bytes instead. So this test is rather
        conservative (if it fails, then it will fail for all interpretations).

        See :cpp:func:`OGRFeature::Validate`.

        Parameters
        -----------
        flags : int, default = :py:const:`F_VAL_ALL`
            One ore more of :py:const:`OGR_F_VAL_NULL`,
            :py:const:`OGR_F_VAL_GEOM_TYPE`, py:const:`OGR_F_VAL_WIDTH` and
            :py:const:`OGR_F_VAL_ALLOW_NULL_WHEN_DEFAULT` combined with
            the with ``|`` operator
        bEmitError : bool, default = True
            TRUE if a CPLError() must be emitted when a check fails

        Returns
        -------
        int:
            TRUE if all enabled validation tests pass.

        """
        return _ogr.Feature_Validate(self, *args)

    def FillUnsetWithDefault(self, *args):
        r"""
        FillUnsetWithDefault(Feature self, int bNotNullableOnly=FALSE, char ** options=None)


        Fill unset fields with default values that might be defined.

        See :cpp:func:`OGRFeature::FillUnsetWithDefault`.

        Parameters
        -----------
        bNotNullableOnly : bool
            if we should fill only unset fields with a not-null
            constraint.
        options : dict
            unused currently.

        """
        return _ogr.Feature_FillUnsetWithDefault(self, *args)

    def GetNativeData(self, *args):
        r"""
        GetNativeData(Feature self) -> char const *


        Returns the native data for the feature.

        The native data is the representation in a "natural" form that comes
        from the driver that created this feature, or that is aimed at an
        output driver. The native data may be in different format, which is
        indicated by :py:func:`GetNativeMediaType`.

        Note that most drivers do not support storing the native data in the
        feature object, and if they do, generally the ``NATIVE_DATA`` open option
        must be passed at dataset opening.

        The "native data" does not imply it is something more performant or
        powerful than what can be obtained with the rest of the API, but it
        may be useful in round-tripping scenarios where some characteristics
        of the underlying format are not captured otherwise by the OGR
        abstraction.

        See :cpp:func:`OGRFeature::GetNativeData` and :ref:`rfc-60`.

        Returns
        -------
        str:
            a string with the native data, or ``None``.

        """
        return _ogr.Feature_GetNativeData(self, *args)

    def GetNativeMediaType(self, *args):
        r"""
        GetNativeMediaType(Feature self) -> char const *


        Returns the native media type for the feature.

        The native media type is the identifier for the format of the native
        data. It follows the IANA RFC 2045
        (seehttps://en.wikipedia.org/wiki/Media_type), e.g.
        "application/vnd.geo+json" for JSon.

        See :cpp:func:`OGRFeature::GetNativeMediaType` and :ref:`rfc-60`.

        Returns
        --------
        str:
            a string with the native media type, or ``None``.

        """
        return _ogr.Feature_GetNativeMediaType(self, *args)

    def SetNativeData(self, *args):
        r"""
        SetNativeData(Feature self, char const * nativeData)


        Sets the native data for the feature.

        The native data is the representation in a "natural" form that comes
        from the driver that created this feature, or that is aimed at an
        output driver. The native data may be in different format, which is
        indicated by :py:meth:`GetNativeMediaType`.

        See :cpp:func:`OGRFeature::SetNativeData` and :ref:`rfc-60`.

        Parameters
        -----------
        nativeData : str
            a string with the native data, or ``None``

        """
        return _ogr.Feature_SetNativeData(self, *args)

    def SetNativeMediaType(self, *args):
        r"""
        SetNativeMediaType(Feature self, char const * nativeMediaType)


        Sets the native media type for the feature.

        The native media type is the identifier for the format of the native
        data. It follows the IANA RFC 2045
        (see https://en.wikipedia.org/wiki/Media_type), e.g.
        "application/vnd.geo+json" for JSon.

        See :cpp:func:`OGRFeature::SetNativeMediaType` and :ref:`rfc-60`.

        Parameters
        -----------
        nativeMediaType : str
            a string with the native media type, or ``None``

        """
        return _ogr.Feature_SetNativeMediaType(self, *args)

    def SetFieldString(self, *args):
        r"""
        SetFieldString(Feature self, int id, char const * value)


        Set field to string value.

        :py:const:`OFTInteger` fields will be set based on an atoi() conversion of the
        string. :py:const:`OFTInteger64` fields will be set based on an :cpp:func:`CPLAtoGIntBig`
        conversion of the string. :py:const:`OFTReal` fields will be set based on an
        :cpp:func:`CPLAtof` conversion of the string. Other field types may be
        unaffected.

        See :cpp:func:`OGRFeature::SetField`.

        This method has only an effect on the in-memory feature object. If
        this object comes from a layer and the modifications must be
        serialized back to the datasource, :py:meth:`Layer.SetFeature` must be used
        afterwards. Or if this is a new feature, :py:meth:`Layer.CreateFeature` must be
        used afterwards.

        Parameters
        -----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.
        value:
            the value to assign.

        """
        return _ogr.Feature_SetFieldString(self, *args)

    def Reference(self):
      pass

    def Dereference(self):
      pass

    def Destroy(self):
      "Once called, self has effectively been destroyed.  Do not access. For backwards compatibility only"
      _ogr.delete_Feature(self)
      self._invalidate_geom_refs()
      self.thisown = 0
      self.this = None

    def __cmp__(self, other):
        """Compares a feature to another for equality"""
        return self.Equal(other)

    def __copy__(self):
        return self.Clone()

    def _getfieldindex(self, fieldname):
        case_insensitive_idx = -1
        fdefn = _ogr.Feature_GetDefnRef(self)
        for i in range(fdefn.GetFieldCount()):
            name = fdefn.GetFieldDefn(i).GetName()
            if name == fieldname:
                return i
            elif case_insensitive_idx < 0 and name.lower() == fieldname.lower():
                case_insensitive_idx = i
        return case_insensitive_idx

    # This makes it possible to fetch fields in the form "feature.area".
    # This has some risk of name collisions.
    def __getattr__(self, key):
        """Returns the values of fields by the given name"""
        if key in ('this', 'thisown', '_geom_references'):
            return self.__getattribute__(key)

        idx = self._getfieldindex(key)
        if idx < 0:
            idx = self.GetGeomFieldIndex(key)
            if idx < 0:
                raise AttributeError(key)
            else:
                return self.GetGeomFieldRef(idx)
        else:
            return self.GetField(idx)

    # This makes it possible to set fields in the form "feature.area".
    # This has some risk of name collisions.
    def __setattr__(self, key, value):
        """Set the values of fields by the given name"""
        if key in ('this', 'thisown', '_geom_references'):
            super().__setattr__(key, value)
        else:
            idx = self._getfieldindex(key)
            if idx != -1:
                self._SetField2(idx, value)
            else:
                idx = self.GetGeomFieldIndex(key)
                if idx != -1:
                    self.SetGeomField(idx, value)
                else:
                    self.__dict__[key] = value

    # This makes it possible to fetch fields in the form "feature['area']".
    def __getitem__(self, key):
        """Returns the values of fields by the given name / field_index"""
        if isinstance(key, str):
            fld_index = self._getfieldindex(key)
        else:
            fld_index = key
            if key == self.GetFieldCount():
                raise IndexError
        if fld_index < 0:
            if isinstance(key, str):
                fld_index = self.GetGeomFieldIndex(key)
            if fld_index < 0:
                raise KeyError("Illegal field requested in GetField()")
            else:
                return self.GetGeomFieldRef(fld_index)
        else:
            return self.GetField(fld_index)

    # This makes it possible to set fields in the form "feature['area'] = 123".
    def __setitem__(self, key, value):
        """Returns the value of a field by field name / index"""
        if isinstance(key, str):
            fld_index = self._getfieldindex(key)
        else:
            fld_index = key
            if key == self.GetFieldCount():
                raise IndexError
        if fld_index < 0:
            if isinstance(key, str):
                fld_index = self.GetGeomFieldIndex(key)
            if fld_index < 0:
                raise KeyError("Illegal field requested in SetField()")
            else:
                return self.SetGeomField(fld_index, value)
        else:
            return self._SetField2(fld_index, value)

    def GetField(self, fld_index):
        """
        Get the value of a field in its native type.

        Alternatively, the ``[]`` operator may be used.

        Parameters
        ----------
        fld_index : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Examples
        --------
        >>> with gdal.OpenEx("data/poly.shp") as ds:
        ...     lyr = ds.GetLayer(0)
        ...     feature = lyr.GetNextFeature()
        ...     # name-based access
        ...     feature.GetField("EAS_ID")
        ...     feature["EAS_ID"]
        ...     # index-based access
        ...     index = feature.GetFieldIndex("EAS_ID")
        ...     feature.GetField(index)
        ...     feature[index]
        ...
        168
        168
        168
        168
        """
        if isinstance(fld_index, str):
            fld_index = self._getfieldindex(fld_index)
        if (fld_index < 0) or (fld_index > self.GetFieldCount()):
            raise KeyError("Illegal field requested in GetField()")
        if not (self.IsFieldSet(fld_index)) or self.IsFieldNull(fld_index):
            return None
        fld_type = self.GetFieldType(fld_index)
        if fld_type == OFTInteger:
            if self.GetFieldDefnRef(fld_index).GetSubType() == OFSTBoolean:
                return bool(self.GetFieldAsInteger(fld_index))
            return self.GetFieldAsInteger(fld_index)
        if fld_type == OFTInteger64:
            return self.GetFieldAsInteger64(fld_index)
        if fld_type == OFTReal:
            return self.GetFieldAsDouble(fld_index)
        if fld_type == OFTStringList:
            return self.GetFieldAsStringList(fld_index)
        if fld_type == OFTIntegerList:
            ret = self.GetFieldAsIntegerList(fld_index)
            if self.GetFieldDefnRef(fld_index).GetSubType() == OFSTBoolean:
                 ret = [bool(x) for x in ret]
            return ret
        if fld_type == OFTInteger64List:
            return self.GetFieldAsInteger64List(fld_index)
        if fld_type == OFTRealList:
            return self.GetFieldAsDoubleList(fld_index)
    ## if fld_type == OFTDateTime or fld_type == OFTDate or fld_type == OFTTime:
    #     return self.GetFieldAsDate(fld_index)
    # default to returning as a string.  Should we add more types?
        try:
            return self.GetFieldAsString(fld_index)
        except:
    # For Python3 on non-UTF8 strings
            return self.GetFieldAsBinary(fld_index)

    def SetFieldBinary(self, field_index_or_name, value):
        """
        SetFieldBinary(Feature self, field_index_or_name: int | str, value: bytes)

        Set field to binary data.
        This function currently only has an effect on :py:const:`OFTBinary` fields.
        This function is the same as the C++ method :cpp:func:`OGRFeature::SetField`.

        Parameters
        -----------
        field_index_or_name:
            the field to set, from 0 to GetFieldCount()-1. Or the field name
        values:
            the data to apply.
        """

        if isinstance(field_index_or_name, str):
            fld_index = self._getfieldindex(field_index_or_name)
        else:
            fld_index = field_index_or_name
        self._SetFieldBinary(fld_index, value)

    def _SetField2(self, fld_index, value):
        if isinstance(fld_index, str):
            fld_index = self._getfieldindex(fld_index)
        if (fld_index < 0) or (fld_index > self.GetFieldCount()):
            raise KeyError("Illegal field requested in _SetField2()")

        if value is None:
            self.SetFieldNull(fld_index)
            return

        if isinstance(value, list):
            if not value:
                self.SetFieldNull(fld_index)
                return
            if isinstance(value[0], type(1)) or isinstance(value[0], type(12345678901234)):
                self.SetFieldInteger64List(fld_index, value)
                return
            elif isinstance(value[0], float):
                self.SetFieldDoubleList(fld_index, value)
                return
            elif isinstance(value[0], str):
                self.SetFieldStringList(fld_index, value)
                return
            else:
                raise TypeError('Unsupported type of list in _SetField2(). Type of element is %s' % str(type(value[0])))

        if isinstance(value, (bytes, bytearray, memoryview)) and self.GetFieldType(fld_index) == OFTBinary:
            self._SetFieldBinary(fld_index, value)
            return

        try:
            self.SetField(fld_index, value)
        except:
            self.SetField(fld_index, str(value))
        return

    def keys(self):
        """Return the list of field names (of the layer definition)"""
        names = []
        for i in range(self.GetFieldCount()):
            fieldname = self.GetFieldDefnRef(i).GetName()
            names.append(fieldname)
        return names

    def items(self):
        """Return a dictionary with the field names as key, and their value in the feature"""
        keys = self.keys()
        output = {}
        for key in keys:
            output[key] = self.GetField(key)
        return output

    def geometry(self):
        """ Return the feature geometry

            The lifetime of the returned geometry is bound to the one of its belonging
            feature.

            For more details: :cpp:func:`OGR_F_GetGeometryRef`

            The GetGeometryRef() method is also available as an alias of geometry()

            Returns
            --------
            Geometry:
                the geometry, or None.
        """

        return self.GetGeometryRef()

    def __del__(self):
        self._invalidate_geom_refs()

    def __repr__(self):
        return self.DumpReadableAsString()


    def ExportToJson(self, as_object=False, options=None):
        """
        Export a GeoJSON object which represents the Feature.

        Parameters
        ----------
        as_object : bool, default = False
            determines whether the returned value should be a Python object instead of a string.
        options : dict/str
            Options to pass to :py:func:`Geometry.ExportToJson`

        Returns
        -------
        str / dict
        """
        try:
            import simplejson
        except ImportError:
            try:
                import json as simplejson
            except ImportError:
                raise ImportError("Unable to import simplejson or json, needed for ExportToJson.")

        geom = self.GetGeometryRef()
        if geom is not None:
            if options is None:
                options = []
            geom_json_string = geom.ExportToJson(options=options)
            geom_json_object = simplejson.loads(geom_json_string)
        else:
            geom_json_object = None

        output = {'type':'Feature',
                   'geometry': geom_json_object,
                   'properties': {}
                  }

        fid = self.GetFID()
        if fid != NullFID:
            output['id'] = fid

        for key in self.keys():
            fld_defn = self.GetFieldDefnRef(self.GetFieldIndex(key))
            if fld_defn.GetType() == _ogr.OFTInteger and fld_defn.GetSubType() == _ogr.OFSTBoolean:
                output['properties'][key] = bool(self.GetField(key))
            else:
                output['properties'][key] = self.GetField(key)

        if not as_object:
            output = simplejson.dumps(output)

        return output


    def _add_geom_ref(self, geom):
        if geom is None:
            return

        if not hasattr(self, '_geom_references'):
            import weakref

            self._geom_references = weakref.WeakSet()

        self._geom_references.add(geom)


    def _invalidate_geom_refs(self):
        if hasattr(self, '_geom_references'):
            for geom in self._geom_references:
                geom.this = None



# Register Feature in _ogr:
_ogr.Feature_swigregister(Feature)
class FeatureDefn(object):
    r"""


    Python proxy of an :cpp:class:`OGRFeatureDefn`.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_FeatureDefn

    def __init__(self, *args, **kwargs):
        r"""
        __init__(FeatureDefn self, char const * name_null_ok=None) -> FeatureDefn


        Create a new feature definition object to hold the field definitions.

        Parameters
        ----------
        name_null_ok : str, optional
            Name for the :py:class:`FeatureDefn`.

        """
        _ogr.FeatureDefn_swiginit(self, _ogr.new_FeatureDefn(*args, **kwargs))

    def GetName(self, *args):
        r"""
        GetName(FeatureDefn self) -> char const *


        Get name of the :py:class:`FeatureDefn`.

        See :cpp:func:`OGRFeatureDefn::GetName`.

        Returns
        --------
        str:
            the name

        """
        return _ogr.FeatureDefn_GetName(self, *args)

    def GetFieldCount(self, *args):
        r"""
        GetFieldCount(FeatureDefn self) -> int


        Fetch number of fields on the passed feature definition.

        See :cpp:func:`OGRFeatureDefn::GetFieldCount`.

        Returns
        --------
        int:
            count of fields.

        """
        return _ogr.FeatureDefn_GetFieldCount(self, *args)

    def GetFieldDefn(self, *args):
        r"""
        GetFieldDefn(FeatureDefn self, int i) -> FieldDefn


        Fetch field definition of the passed feature definition.

        See :cpp:func:`OGRFeatureDefn::GetFieldDefn`.

        Parameters
        -----------
        i : int / str
            Field name or 0-based numeric index. For repeated
            access, use of the numeric index avoids a lookup
            step.

        Returns
        --------
        FieldDefn:
            internal field definition object or ``None`` if the field does not
            exist. This object should not be modified by the application.

        """

        if type(args[0]) is str:
            args = (self.GetFieldIndex(args[0]), )


        return _ogr.FeatureDefn_GetFieldDefn(self, *args)


    def GetFieldIndex(self, *args):
        r"""
        GetFieldIndex(FeatureDefn self, char const * field_name) -> int


        Find field by name.

        The field index of the first field matching the passed field name
        (case insensitively) is returned.

        See :cpp:func:`OGRFeatureDefn::GetFieldIndex`.

        Parameters
        -----------
        field_name : str
            the field name to search for.

        Returns
        --------
        int:
            the field index, or -1 if no match found.

        """
        return _ogr.FeatureDefn_GetFieldIndex(self, *args)

    def AddFieldDefn(self, *args):
        r"""
        AddFieldDefn(FeatureDefn self, FieldDefn defn)


        Add a new field definition.

        To add a new field definition to a layer definition, do not use this
        function directly, but use :py:meth:`Layer.CreateField` instead.

        This function should only be called while there are no :py:class:`Feature`
        objects in existence based on this :py:class:`FeatureDefn`. The
        :py:class:`FieldDefn` passed in is copied.

        See :cpp:func:`OGRFeatureDefn::AddFieldDefn`.

        Parameters
        -----------
        defn : FieldDefn
            the new field definition.

        """
        return _ogr.FeatureDefn_AddFieldDefn(self, *args)

    def GetGeomFieldCount(self, *args):
        r"""
        GetGeomFieldCount(FeatureDefn self) -> int


        Fetch number of geometry fields on the passed feature definition.

        See :cpp:func:`OGRFeatureDefn::GetGeomFieldCount`.

        Returns
        --------
        int:
            count of geometry fields.

        """
        return _ogr.FeatureDefn_GetGeomFieldCount(self, *args)

    def GetGeomFieldDefn(self, *args):
        r"""
        GetGeomFieldDefn(FeatureDefn self, int i) -> GeomFieldDefn


        Fetch geometry field definition of the passed feature definition.

        See :cpp:func:`OGRFeatureDefn::GetGeomFieldDefn`.

        Parameters
        -----------
        i : int
            the geometry field to fetch, between 0 and GetGeomFieldCount() - 1.

        Returns
        --------
        GeomFieldDefn:
            an internal field definition object or ``None`` if invalid
            index. This object should not be modified by the application.

        """
        return _ogr.FeatureDefn_GetGeomFieldDefn(self, *args)

    def GetGeomFieldIndex(self, *args):
        r"""
        GetGeomFieldIndex(FeatureDefn self, char const * field_name) -> int


        Find geometry field by name.

        The geometry field index of the first geometry field matching the
        passed field name (case insensitively) is returned.

        See :cpp:func:`OGRFeatureDefn::GetGeomFieldIndex`.

        Parameters
        -----------
        field_name : str
            the geometry field name to search for.

        Returns
        --------
        int:
            the geometry field index, or -1 if no match found.

        """
        return _ogr.FeatureDefn_GetGeomFieldIndex(self, *args)

    def AddGeomFieldDefn(self, *args):
        r"""
        AddGeomFieldDefn(FeatureDefn self, GeomFieldDefn defn)


        Add a new geometry field definition.

        To add a new field definition to a layer definition, do not use this
        function directly, but use :py:meth:`Layer.CreateGeomField` instead.

        This function should only be called while there are no :py:class:`Feature`
        objects in existence based on this :py:class:`FeatureDefn`. The
        :py:class:`GeomFieldDefn` passed in is copied.

        See :cpp:Func:`OGRFeatureDefn::AddGeomFieldDefn`.

        Parameters
        -----------
        defn : GeomFieldDefn
            new geometry field definition.

        """
        return _ogr.FeatureDefn_AddGeomFieldDefn(self, *args)

    def DeleteGeomFieldDefn(self, *args):
        r"""
        DeleteGeomFieldDefn(FeatureDefn self, int idx) -> OGRErr


        Delete an existing geometry field definition.

        To delete an existing geometry field definition from a layer
        definition, do not use this function directly, but use
        :py:meth:`Layer.DeleteGeomField` instead ( not implemented yet).

        This function should only be called while there are no :py:class:`Feature`
        objects in existence based on this :py:class:`FeatureDefn`.

        See :cpp:func:`OGRFeatureDefn::DeleteGeomFieldDefn`.

        Parameters
        -----------
        idx : int
            the index of the geometry field definition.

        Returns
        --------
        int:
            :py:const:`OGRERR_NONE` in case of success.

        """
        return _ogr.FeatureDefn_DeleteGeomFieldDefn(self, *args)

    def GetGeomType(self, *args):
        r"""
        GetGeomType(FeatureDefn self) -> OGRwkbGeometryType


        Fetch the geometry base type of the passed feature definition.

        This is equivalent to ``GetGeomFieldDefn(0).GetType()``.

        See :cpp:func:`OGRFeatureDefn::GetGeomType`.

        Returns
        --------
        int :
            the base type for all geometry related to this definition.

        """
        return _ogr.FeatureDefn_GetGeomType(self, *args)

    def SetGeomType(self, *args):
        r"""
        SetGeomType(FeatureDefn self, OGRwkbGeometryType geom_type)


        Assign the base geometry type for the passed layer (the same as the
        feature definition).

        This is equivalent to ``GetGeomFieldDefn(0).SetType()``.

        All geometry objects using this type must be of the defined type or a
        derived type. The default upon creation is :py:const:`wkbUnknown` which allows for
        any geometry type. The geometry type should generally not be changed
        after any :py:class:`Feature` objects have been created against this definition.

        See :cpp:func:`OGRFeatureDefn::SetGeomType`.

        Parameters
        -----------
        geom_type : int
            the new type to assign.

        """
        return _ogr.FeatureDefn_SetGeomType(self, *args)

    def GetReferenceCount(self, *args):
        r"""
        GetReferenceCount(FeatureDefn self) -> int


        Fetch current reference count.

        See :cpp:func:`OGRFeatureDefn::GetReferenceCount`.

        Returns
        --------
        int:
            the current reference count.

        """
        return _ogr.FeatureDefn_GetReferenceCount(self, *args)

    def IsGeometryIgnored(self, *args):
        r"""
        IsGeometryIgnored(FeatureDefn self) -> int


        Determine whether the geometry can be omitted when fetching features.

        Equivalent to ``GetGeomFieldDefn(0).IsIgnored()``.

        See :cpp:func:`OGRFeatureDefn::IsGeometryIgnored`.

        Returns
        --------
        int:
            ignore state

        """
        return _ogr.FeatureDefn_IsGeometryIgnored(self, *args)

    def SetGeometryIgnored(self, *args):
        r"""
        SetGeometryIgnored(FeatureDefn self, int bIgnored)


        Set whether the geometry can be omitted when fetching features.

        This is equivalent to ``GetGeomFieldDefn(0).SetIgnored()``.

        See :cpp:func:`OGRFeatureDefn::SetGeometryIgnored`.

        Parameters
        -----------
        bignored : bool
            ignore state

        """
        return _ogr.FeatureDefn_SetGeometryIgnored(self, *args)

    def IsStyleIgnored(self, *args):
        r"""
        IsStyleIgnored(FeatureDefn self) -> int


        Determine whether the style can be omitted when fetching features.

        See :cpp:func:`OGRFeatureDefn::IsStyleIgnored`.

        Returns
        --------
        int:
            ignore state

        """
        return _ogr.FeatureDefn_IsStyleIgnored(self, *args)

    def SetStyleIgnored(self, *args):
        r"""
        SetStyleIgnored(FeatureDefn self, int bIgnored)


        Set whether the style can be omitted when fetching features.

        See :cpp:func:`OGRFeatureDefn::SetStyleIgnored`.

        Parameters
        -----------
        bignored : bool
            ignore state

        """
        return _ogr.FeatureDefn_SetStyleIgnored(self, *args)

    def IsSame(self, *args):
        r"""
        IsSame(FeatureDefn self, FeatureDefn other_defn) -> int


        Test if the feature definition is identical to the other one.

        Parameters
        -----------
        other_defn : FeatureDefn
            other feature definition to compare to.

        Returns
        --------
        int:
            1 if the feature definition is identical to the other one.

        """
        return _ogr.FeatureDefn_IsSame(self, *args)

    def Destroy(self):
      "Once called, self has effectively been destroyed.  Do not access. For backwards compatibility only"
      _ogr.delete_FeatureDefn(self)
      self.thisown = 0



# Register FeatureDefn in _ogr:
_ogr.FeatureDefn_swigregister(FeatureDefn)
class FieldDefn(object):
    r"""

    Python proxy of an :cpp:class:`OGRFieldDefn`.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_FieldDefn

    def __init__(self, *args, **kwargs):
        r"""
        __init__(FieldDefn self, char const * name_null_ok="unnamed", OGRFieldType field_type=OFTString) -> FieldDefn

        Python proxy of an :cpp:class:`OGRFieldDefn`.

        """
        _ogr.FieldDefn_swiginit(self, _ogr.new_FieldDefn(*args, **kwargs))

    def GetName(self, *args):
        r"""GetName(FieldDefn self) -> char const *"""
        return _ogr.FieldDefn_GetName(self, *args)

    def GetNameRef(self, *args):
        r"""
        GetNameRef(FieldDefn self) -> char const *


        Fetch name of this field.

        See :cpp:func:`OGRFieldDefn::GetNameRef`.

        Returns
        --------
        str:
            the name of the field definition.

        """
        return _ogr.FieldDefn_GetNameRef(self, *args)

    def SetName(self, *args):
        r"""
        SetName(FieldDefn self, char const * name)


        Reset the name of this field.

        See :cpp:func:`OGRFieldDefn::SetName`.

        Parameters
        -----------
        name : str
            the new name to apply

        """
        return _ogr.FieldDefn_SetName(self, *args)

    def GetAlternativeName(self, *args):
        r"""GetAlternativeName(FieldDefn self) -> char const *"""
        return _ogr.FieldDefn_GetAlternativeName(self, *args)

    def GetAlternativeNameRef(self, *args):
        r"""
        GetAlternativeNameRef(FieldDefn self) -> char const *


        Fetch the alternative name (or "alias") for this field.

        The alternative name is an optional attribute for a field which can
        provide a more user-friendly, descriptive name of a field which is not
        subject to the usual naming constraints defined by the data provider.

        This is a metadata style attribute only: the alternative name cannot
        be used in place of the actual field name during SQL queries or other
        field name dependent API calls.

        See :cpp:func:`OGRFieldDefn::GetAlternativeNameRef`.

        .. versionadded:: 3.2

        Returns
        --------
        str:
            the alternative name of the field definition.

        """
        return _ogr.FieldDefn_GetAlternativeNameRef(self, *args)

    def SetAlternativeName(self, *args):
        r"""
        SetAlternativeName(FieldDefn self, char const * alternativeName)


        Reset the alternative name (or "alias") for this field.

        The alternative name is an optional attribute for a field which can
        provide a more user-friendly, descriptive name of a field which is not
        subject to the usual naming constraints defined by the data provider.

        This is a metadata style attribute only: the alternative name cannot
        be used in place of the actual field name during SQL queries or other
        field name dependent API calls.

        See :cpp:func:`OGRFieldDefn::SetAlternativeName`.

        .. versionadded:: 3.2

        Parameters
        -----------
        alternativeName : str
            the new alternative name to apply.

        """
        return _ogr.FieldDefn_SetAlternativeName(self, *args)

    def GetType(self, *args):
        r"""
        GetType(FieldDefn self) -> OGRFieldType


        Fetch type of this field.

        See :cpp:func:`OGRFieldDefn::GetType`.

        Returns
        --------
        int
            field type code, e.g. :py:const:`OFTInteger`

        """
        return _ogr.FieldDefn_GetType(self, *args)

    def SetType(self, *args):
        r"""
        SetType(FieldDefn self, OGRFieldType type)


        Set the type of this field.

        This should never be done to a :py:class:`FieldDefn` that is already part of
        an :py:class:`FeatureDefn`.

        See :cpp:func:`OGRFieldDefn::SetType`.

        Parameters
        -----------
        type : int
            the new field type.

        Examples
        --------
        >>> f = ogr.FieldDefn()
        >>> f.SetType(ogr.OFTReal)

        """
        return _ogr.FieldDefn_SetType(self, *args)

    def GetSubType(self, *args):
        r"""
        GetSubType(FieldDefn self) -> OGRFieldSubType


        Fetch subtype of this field.

        See :cpp:func:`OGRFieldDefn::GetSubType`.

        Returns
        --------
        int
            field subtype code, default = :py:const:`OFSTNone`

        """
        return _ogr.FieldDefn_GetSubType(self, *args)

    def SetSubType(self, *args):
        r"""
        SetSubType(FieldDefn self, OGRFieldSubType type)


        Set the subtype of this field.

        This should never be done to a :py:class:`FieldDefn` that is already part of
        an :py:class:FeatureDefn`.

        See :cpp:func:`OGRFieldDefn::SetSubType`.

        Parameters
        -----------
        type :
            the new field subtype.

        Examples
        --------
        >>> f = ogr.FieldDefn()
        >>> f.SetType(ogr.OFTReal)
        >>> f.SetSubType(ogr.OFSTJSON)
        Warning 1: Type and subtype of field definition are not compatible. Resetting to OFSTNone
        >>> f.SetSubType(ogr.OFSTFloat32)

        """
        return _ogr.FieldDefn_SetSubType(self, *args)

    def GetJustify(self, *args):
        r"""
        GetJustify(FieldDefn self) -> OGRJustification


        Get the justification for this field.

        See :cpp:func:`OGRFieldDefn::GetJustify`.

        Note: no driver is know to use the concept of field justification.

        Returns
        --------
        OGRJustification:
            the justification.

        """
        return _ogr.FieldDefn_GetJustify(self, *args)

    def SetJustify(self, *args):
        r"""
        SetJustify(FieldDefn self, OGRJustification justify)


        Set the justification for this field.

        Note: no driver is know to use the concept of field justification.

        See :cpp:func:`OGRFieldDefn::SetJustify`.

        Parameters
        -----------
        justify : int
            the new justification

        Examples
        --------
        >>> f = ogr.FieldDefn('desc', ogr.OFTString)
        >>> f.SetJustify(ogr.OJRight)

        """
        return _ogr.FieldDefn_SetJustify(self, *args)

    def GetWidth(self, *args):
        r"""
        GetWidth(FieldDefn self) -> int


        Get the formatting width for this field.

        See :cpp:func:`OGRFieldDefn::GetWidth`.

        Returns
        --------
        int:
            the width, zero means no specified width.

        """
        return _ogr.FieldDefn_GetWidth(self, *args)

    def SetWidth(self, *args):
        r"""
        SetWidth(FieldDefn self, int width)


        Set the formatting width for this field in characters.

        See :cpp:func:`OGRFieldDefn::SetWidth`.

        Parameters
        -----------
        width : int
            the new width

        """
        return _ogr.FieldDefn_SetWidth(self, *args)

    def GetPrecision(self, *args):
        r"""
        GetPrecision(FieldDefn self) -> int


        Get the formatting precision for this field.

        This should normally be zero for fields of types other than :py:const:`OFTReal`.

        See :cpp:func:`OGRFieldDefn::GetPrecision`.

        Returns
        --------
        int:
            the precision.

        """
        return _ogr.FieldDefn_GetPrecision(self, *args)

    def SetPrecision(self, *args):
        r"""
        SetPrecision(FieldDefn self, int precision)


        Set the formatting precision for this field in characters.

        This should normally be zero for fields of types other than :py:const:`OFTReal`.

        See :cpp:func:`OGRFieldDefn::SetPrecision`.

        Parameters
        -----------
        precision : int
            the new precision.

        """
        return _ogr.FieldDefn_SetPrecision(self, *args)

    def GetTZFlag(self, *args):
        r"""GetTZFlag(FieldDefn self) -> int"""
        return _ogr.FieldDefn_GetTZFlag(self, *args)

    def SetTZFlag(self, *args):
        r"""SetTZFlag(FieldDefn self, int tzflag)"""
        return _ogr.FieldDefn_SetTZFlag(self, *args)

    def GetTypeName(self, *args):
        r"""GetTypeName(FieldDefn self) -> char const *"""
        return _ogr.FieldDefn_GetTypeName(self, *args)

    def GetFieldTypeName(self, *args):
        r"""GetFieldTypeName(FieldDefn self, OGRFieldType type) -> char const *"""
        return _ogr.FieldDefn_GetFieldTypeName(self, *args)

    def IsIgnored(self, *args):
        r"""
        IsIgnored(FieldDefn self) -> int


        Return whether this field should be omitted when fetching features.

        See :cpp:func:`OGRFieldDefn::IsIgnored`.

        Returns
        --------
        int:
            ignore state

        """
        return _ogr.FieldDefn_IsIgnored(self, *args)

    def SetIgnored(self, *args):
        r"""
        SetIgnored(FieldDefn self, int bIgnored)


        Set whether this field should be omitted when fetching features.

        See :cpp:func:`OGRFieldDefn::SetIgnored`.

        Parameters
        -----------
        bignored : bool
            ignore state

        """
        return _ogr.FieldDefn_SetIgnored(self, *args)

    def IsNullable(self, *args):
        r"""
        IsNullable(FieldDefn self) -> int


        Return whether this field can receive null values.

        By default, fields are nullable.

        Even if this method returns FALSE (i.e not-nullable field), it doesn't
        mean that :py:meth:`Feature.IsFieldSet` will necessary return TRUE, as
        fields can be temporary unset and null/not-null validation is usually
        done when :py:meth:`Layer.CreateFeature`/:py:meth:`Layer.SetFeature` is called.

        See :cpp:func:`OGRFieldDefn::IsNullable`.

        Returns
        --------
        int:
            TRUE if the field is authorized to be null.

        """
        return _ogr.FieldDefn_IsNullable(self, *args)

    def SetNullable(self, *args):
        r"""
        SetNullable(FieldDefn self, int bNullable)


        Set whether this field can receive null values.

        By default, fields are nullable, so this method is generally called
        with ``False`` to set a not-null constraint.

        Drivers that support writing not-null constraint will advertise the
        ``GDAL_DCAP_NOTNULL_FIELDS`` driver metadata item.

        See :cpp:func:`OGRFieldDefn::SetNullable`.

        Parameters
        -----------
        bNullable : bool
            ``False`` if the field must have a not-null constraint.

        """
        return _ogr.FieldDefn_SetNullable(self, *args)

    def IsUnique(self, *args):
        r"""
        IsUnique(FieldDefn self) -> int


        Return whether this field has a unique constraint.

        By default, fields have no unique constraint.

        See :cpp:func:`OGRFieldDefn::IsUnique`.

        .. versionadded:: 3.2

        Returns
        --------
        int:
            TRUE if the field has a unique constraint.

        """
        return _ogr.FieldDefn_IsUnique(self, *args)

    def SetUnique(self, *args):
        r"""
        SetUnique(FieldDefn self, int bUnique)


        Set whether this field has a unique constraint.

        By default, fields have no unique constraint, so this method is
        generally called with TRUE to set a unique constraint.

        Drivers that support writing unique constraint will advertise the
        ``GDAL_DCAP_UNIQUE_FIELDS`` driver metadata item.

        Note that once a :py:class:`FieldDefn` has been added to a layer definition with
        :py:meth:`Layer.AddFieldDefn`, its setter methods should not be called on the
        object returned with ``GetLayerDefn().GetFieldDefn()``. Instead,
        :py:meth:`Layer::AlterFieldDefn` should be called on a new instance of
        :py:class:`FieldDefn`, for drivers that support :py:meth:`Layer.AlterFieldDefn`.

        See :cpp:func:`OGRFieldDefn::SetUnique`.

        .. versionadded:: 3.2

        Parameters
        -----------
        bUnique : bool
            ``True`` if the field must have a unique constraint

        """
        return _ogr.FieldDefn_SetUnique(self, *args)

    def GetDefault(self, *args):
        r"""
        GetDefault(FieldDefn self) -> char const *


        Get default field value.

        See :cpp:func:`OGRFieldDefn::GetDefault`.

        Returns
        --------
        str:
            default field value or ``None``.

        """
        return _ogr.FieldDefn_GetDefault(self, *args)

    def SetDefault(self, *args):
        r"""
        SetDefault(FieldDefn self, char const * pszValue)


        Set default field value.

        The default field value is taken into account by drivers (generally
        those with a SQL interface) that support it at field creation time.
        OGR will generally not automatically set the default field value to
        null fields by itself when calling OGRFeature::CreateFeature() /
        OGRFeature::SetFeature(), but will let the low-level layers to do the
        job. So retrieving the feature from the layer is recommended.

        The accepted values are NULL, a numeric value, a literal value
        enclosed between single quote characters (and inner single quote
        characters escaped by repetition of the single quote character),
        CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or a driver specific
        expression (that might be ignored by other drivers). For a datetime
        literal value, format should be 'YYYY/MM/DD HH:MM:SS[.sss]'
        (considered as UTC time).

        Drivers that support writing DEFAULT clauses will advertise the
        GDAL_DCAP_DEFAULT_FIELDS driver metadata item.

        See :cpp:func:`OGRFieldDefn::SetDefault`.

        Parameters
        -----------
        pszValue : str
            new default field value or NULL pointer.

        """
        return _ogr.FieldDefn_SetDefault(self, *args)

    def IsDefaultDriverSpecific(self, *args):
        r"""
        IsDefaultDriverSpecific(FieldDefn self) -> int


        Returns whether the default value is driver specific.

        Driver specific default values are those that are not NULL, a numeric
        value, a literal value enclosed between single quote characters,
        CURRENT_TIMESTAMP, CURRENT_TIME, CURRENT_DATE or datetime literal
        value.

        See :cpp:func:`OGRFieldDefn::IsDefaultDriverSpecific`.

        Returns
        --------
        int:
            TRUE if the default value is driver specific.

        """
        return _ogr.FieldDefn_IsDefaultDriverSpecific(self, *args)

    def GetDomainName(self, *args):
        r"""
        GetDomainName(FieldDefn self) -> char const *


        Return the name of the field domain for this field.

        By default an empty string is returned.

        Field domains ( :py:class:`FieldDomain` class) are attached at the :py:class:`Dataset` level and should be retrieved with :py:meth:`Dataset.GetFieldDomain`.

        See :cpp:func:`OGRFieldDefn::GetDomainName`.

        .. versionadded:: 3.3

        Returns
        --------
        str:
            the field domain name, or an empty string if there is none.

        """
        return _ogr.FieldDefn_GetDomainName(self, *args)

    def SetDomainName(self, *args):
        r"""
        SetDomainName(FieldDefn self, char const * name)


        Set the name of the field domain for this field.

        Field domains ( :py:class:`FieldDomain`) are attached at the :py:class:`Dataset` level.

        See :cpp:func:`OGRFieldDefn::SetDomainName`.

        .. versionadded:: 3.3

        Parameters
        -----------
        name : str
            Field domain name.

        """
        return _ogr.FieldDefn_SetDomainName(self, *args)

    def GetComment(self, *args):
        r"""GetComment(FieldDefn self) -> char const *"""
        return _ogr.FieldDefn_GetComment(self, *args)

    def SetComment(self, *args):
        r"""SetComment(FieldDefn self, char const * comment)"""
        return _ogr.FieldDefn_SetComment(self, *args)

    width = property(GetWidth, SetWidth)
    type = property(GetType, SetType)
    precision = property(GetPrecision, SetPrecision)
    name = property(GetName, SetName)
    justify = property(GetJustify, SetJustify)


    def Destroy(self):
      "Once called, self has effectively been destroyed.  Do not access. For backwards compatibility only"
      _ogr.delete_FieldDefn(self)
      self.thisown = 0


# Register FieldDefn in _ogr:
_ogr.FieldDefn_swigregister(FieldDefn)
class GeomFieldDefn(object):
    r"""Proxy of C++ OGRGeomFieldDefnShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_GeomFieldDefn

    def __init__(self, *args, **kwargs):
        r"""__init__(GeomFieldDefn self, char const * name_null_ok="", OGRwkbGeometryType field_type=wkbUnknown) -> GeomFieldDefn"""
        _ogr.GeomFieldDefn_swiginit(self, _ogr.new_GeomFieldDefn(*args, **kwargs))

    def GetName(self, *args):
        r"""GetName(GeomFieldDefn self) -> char const *"""
        return _ogr.GeomFieldDefn_GetName(self, *args)

    def GetNameRef(self, *args):
        r"""GetNameRef(GeomFieldDefn self) -> char const *"""
        return _ogr.GeomFieldDefn_GetNameRef(self, *args)

    def SetName(self, *args):
        r"""SetName(GeomFieldDefn self, char const * name)"""
        return _ogr.GeomFieldDefn_SetName(self, *args)

    def GetType(self, *args):
        r"""GetType(GeomFieldDefn self) -> OGRwkbGeometryType"""
        return _ogr.GeomFieldDefn_GetType(self, *args)

    def SetType(self, *args):
        r"""SetType(GeomFieldDefn self, OGRwkbGeometryType type)"""
        return _ogr.GeomFieldDefn_SetType(self, *args)

    def GetSpatialRef(self, *args):
        r"""GetSpatialRef(GeomFieldDefn self) -> SpatialReference"""
        return _ogr.GeomFieldDefn_GetSpatialRef(self, *args)

    def SetSpatialRef(self, *args):
        r"""SetSpatialRef(GeomFieldDefn self, SpatialReference srs)"""
        return _ogr.GeomFieldDefn_SetSpatialRef(self, *args)

    def IsIgnored(self, *args):
        r"""IsIgnored(GeomFieldDefn self) -> int"""
        return _ogr.GeomFieldDefn_IsIgnored(self, *args)

    def SetIgnored(self, *args):
        r"""SetIgnored(GeomFieldDefn self, int bIgnored)"""
        return _ogr.GeomFieldDefn_SetIgnored(self, *args)

    def IsNullable(self, *args):
        r"""IsNullable(GeomFieldDefn self) -> int"""
        return _ogr.GeomFieldDefn_IsNullable(self, *args)

    def SetNullable(self, *args):
        r"""SetNullable(GeomFieldDefn self, int bNullable)"""
        return _ogr.GeomFieldDefn_SetNullable(self, *args)

    def GetCoordinatePrecision(self, *args):
        r"""GetCoordinatePrecision(GeomFieldDefn self) -> GeomCoordinatePrecision"""
        return _ogr.GeomFieldDefn_GetCoordinatePrecision(self, *args)

    def SetCoordinatePrecision(self, *args):
        r"""SetCoordinatePrecision(GeomFieldDefn self, GeomCoordinatePrecision coordPrec)"""
        return _ogr.GeomFieldDefn_SetCoordinatePrecision(self, *args)

    type = property(GetType, SetType)
    name = property(GetName, SetName)
    srs = property(GetSpatialRef, SetSpatialRef)


# Register GeomFieldDefn in _ogr:
_ogr.GeomFieldDefn_swigregister(GeomFieldDefn)

def CreateGeometryFromWkb(*args, **kwargs):
    r"""CreateGeometryFromWkb(size_t len, SpatialReference reference=None) -> Geometry"""
    return _ogr.CreateGeometryFromWkb(*args, **kwargs)

def CreateGeometryFromWkt(*args, **kwargs):
    r"""CreateGeometryFromWkt(char ** val, SpatialReference reference=None) -> Geometry"""
    return _ogr.CreateGeometryFromWkt(*args, **kwargs)

def CreateGeometryFromGML(*args):
    r"""CreateGeometryFromGML(char const * input_string) -> Geometry"""
    return _ogr.CreateGeometryFromGML(*args)

def CreateGeometryFromJson(*args):
    r"""CreateGeometryFromJson(char const * input_string) -> Geometry"""
    return _ogr.CreateGeometryFromJson(*args)

def CreateGeometryFromEsriJson(*args):
    r"""CreateGeometryFromEsriJson(char const * input_string) -> Geometry"""
    return _ogr.CreateGeometryFromEsriJson(*args)

def BuildPolygonFromEdges(*args, **kwargs):
    r"""BuildPolygonFromEdges(Geometry hLineCollection, int bBestEffort=0, int bAutoClose=0, double dfTolerance=0) -> Geometry"""
    return _ogr.BuildPolygonFromEdges(*args, **kwargs)

def ApproximateArcAngles(*args, **kwargs):
    r"""ApproximateArcAngles(double dfCenterX, double dfCenterY, double dfZ, double dfPrimaryRadius, double dfSecondaryAxis, double dfRotation, double dfStartAngle, double dfEndAngle, double dfMaxAngleStepSizeDegrees) -> Geometry"""
    return _ogr.ApproximateArcAngles(*args, **kwargs)

def ForceToPolygon(*args):
    r"""ForceToPolygon(Geometry geom_in) -> Geometry"""
    return _ogr.ForceToPolygon(*args)

def ForceToLineString(*args):
    r"""ForceToLineString(Geometry geom_in) -> Geometry"""
    return _ogr.ForceToLineString(*args)

def ForceToMultiPolygon(*args):
    r"""ForceToMultiPolygon(Geometry geom_in) -> Geometry"""
    return _ogr.ForceToMultiPolygon(*args)

def ForceToMultiPoint(*args):
    r"""ForceToMultiPoint(Geometry geom_in) -> Geometry"""
    return _ogr.ForceToMultiPoint(*args)

def ForceToMultiLineString(*args):
    r"""ForceToMultiLineString(Geometry geom_in) -> Geometry"""
    return _ogr.ForceToMultiLineString(*args)

def ForceTo(*args):
    r"""ForceTo(Geometry geom_in, OGRwkbGeometryType eTargetType, char ** options=None) -> Geometry"""
    return _ogr.ForceTo(*args)
class Geometry(object):
    r"""Proxy of C++ OGRGeometryShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_Geometry

    def __init__(self, *args, **kwargs):
        r"""__init__(Geometry self, OGRwkbGeometryType type=wkbUnknown, char * wkt=None, int wkb=0, char * gml=None) -> Geometry"""
        _ogr.Geometry_swiginit(self, _ogr.new_Geometry(*args, **kwargs))

    def ExportToWkt(self, *args):
        r"""
        ExportToWkt(Geometry self) -> OGRErr

        Convert a geometry into well known text format.

        For more details: :cpp:func:`OGR_G_ExportToWkt`

        Returns
        --------
        str

        """
        return _ogr.Geometry_ExportToWkt(self, *args)

    def ExportToIsoWkt(self, *args):
        r"""
        ExportToIsoWkt(Geometry self) -> OGRErr

        Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known text
        format.

        For more details: :cpp:func:`OGR_G_ExportToIsoWkt`

        .. versionadded:: 2.0

        Returns
        --------
        str

        """
        return _ogr.Geometry_ExportToIsoWkt(self, *args)

    def ExportToWkb(self, *args, **kwargs):
        r"""
        ExportToWkb(Geometry self, OGRwkbByteOrder byte_order=wkbNDR) -> OGRErr

        Convert a geometry well known binary format.

        For more details: :cpp:func:`OGR_G_ExportToWkb`

        Parameters
        -----------
        byte_order: osgeo.ogr.wkbXDR | osgeo.ogr.wkbNDR, default=osgeo.ogr.wkbNDR
            One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively.

        Returns
        --------
        bytes

        """
        return _ogr.Geometry_ExportToWkb(self, *args, **kwargs)

    def ExportToIsoWkb(self, *args, **kwargs):
        r"""
        ExportToIsoWkb(Geometry self, OGRwkbByteOrder byte_order=wkbNDR) -> OGRErr

        Convert a geometry into SFSQL 1.2 / ISO SQL/MM Part 3 well known
        binary format.

        For more details: :cpp:func:`OGR_G_ExportToIsoWkb`

        .. versionadded:: 2.0

        Parameters
        -----------
        byte_order: osgeo.ogr.wkbXDR | osgeo.ogr.wkbNDR, default=osgeo.ogr.wkbNDR
            One of wkbXDR or wkbNDR indicating MSB or LSB byte order respectively.

        Returns
        --------
        bytes

        """
        return _ogr.Geometry_ExportToIsoWkb(self, *args, **kwargs)

    def ExportToGML(self, *args, **kwargs):
        r"""ExportToGML(Geometry self, char ** options=None) -> retStringAndCPLFree *"""
        return _ogr.Geometry_ExportToGML(self, *args, **kwargs)

    def ExportToKML(self, *args):
        r"""ExportToKML(Geometry self, char const * altitude_mode=None) -> retStringAndCPLFree *"""
        return _ogr.Geometry_ExportToKML(self, *args)

    def ExportToJson(self, *args, **kwargs):
        r"""ExportToJson(Geometry self, char ** options=None) -> retStringAndCPLFree *"""
        return _ogr.Geometry_ExportToJson(self, *args, **kwargs)

    def AddPoint(self, *args, **kwargs):
        r"""AddPoint(Geometry self, double x, double y, double z=0)"""
        return _ogr.Geometry_AddPoint(self, *args, **kwargs)

    def AddPointM(self, *args, **kwargs):
        r"""AddPointM(Geometry self, double x, double y, double m)"""
        return _ogr.Geometry_AddPointM(self, *args, **kwargs)

    def AddPointZM(self, *args, **kwargs):
        r"""AddPointZM(Geometry self, double x, double y, double z, double m)"""
        return _ogr.Geometry_AddPointZM(self, *args, **kwargs)

    def AddPoint_2D(self, *args):
        r"""AddPoint_2D(Geometry self, double x, double y)"""
        return _ogr.Geometry_AddPoint_2D(self, *args)

    def AddGeometryDirectly(self, *args):
        r"""AddGeometryDirectly(Geometry self, Geometry other_disown) -> OGRErr"""
        return _ogr.Geometry_AddGeometryDirectly(self, *args)

    def AddGeometry(self, *args):
        r"""AddGeometry(Geometry self, Geometry other) -> OGRErr"""
        return _ogr.Geometry_AddGeometry(self, *args)

    def RemoveGeometry(self, *args):
        r"""RemoveGeometry(Geometry self, int iSubGeom) -> OGRErr"""
        return _ogr.Geometry_RemoveGeometry(self, *args)

    def Clone(self, *args):
        r"""
        Clone(Geometry self) -> Geometry

        Make a copy of this object.

        For more details: :cpp:func:`OGR_G_Clone`

        Returns
        --------
        Geometry:
            The copy of the geometry with the same spatial reference system
            as the original.

        """
        return _ogr.Geometry_Clone(self, *args)

    def GetGeometryType(self, *args):
        r"""
        GetGeometryType(Geometry self) -> OGRwkbGeometryType

        Fetch geometry type.

        For more details: :cpp:func:`OGR_G_GetGeometryType`

        Returns
        --------
        int:
            The geometry type code. The types can be found with
            'osgeo.ogr.wkb' prefix. For example :py:const:`osgeo.ogr.wkbPolygon`.

        """
        return _ogr.Geometry_GetGeometryType(self, *args)

    def GetGeometryName(self, *args):
        r"""
        GetGeometryName(Geometry self) -> char const *

        Fetch WKT name for geometry type.

        For more details: :cpp:func:`OGR_G_GetGeometryName`

        geometry to get name from.

        Returns
        --------
        str

        """
        return _ogr.Geometry_GetGeometryName(self, *args)

    def Length(self, *args):
        r"""Length(Geometry self) -> double"""
        return _ogr.Geometry_Length(self, *args)

    def Area(self, *args):
        r"""
        Area(Geometry self) -> double

        Compute geometry area.

        The returned area is a 2D Cartesian (planar) area in square units of the
        spatial reference system in use, so potentially 'square degrees' for a
        geometry expressed in a geographic SRS.

        For more details: :cpp:func:`OGR_G_Area`

        Returns
        --------
        float:
            the area of the geometry in square units of the spatial reference
            system in use, or 0.0 for unsupported geometry types.


        """
        return _ogr.Geometry_Area(self, *args)

    def GeodesicArea(self, *args):
        r"""
        GeodesicArea(Geometry self) -> double

        Compute geometry area, considered as a surface on the underlying
        ellipsoid of the SRS attached to the geometry.

        For more details: :cpp:func:`OGR_G_GeodesicArea`

        Returns
        --------
        float:
            the area in square meters, or a negative value for unsupported geometry types.


        """
        return _ogr.Geometry_GeodesicArea(self, *args)

    def IsClockwise(self, *args):
        r"""IsClockwise(Geometry self) -> bool"""
        return _ogr.Geometry_IsClockwise(self, *args)

    def GetArea(self, *args):
        r"""GetArea(Geometry self) -> double"""
        return _ogr.Geometry_GetArea(self, *args)

    def GetPointCount(self, *args):
        r"""GetPointCount(Geometry self) -> int"""
        return _ogr.Geometry_GetPointCount(self, *args)

    def GetPoints(self, *args, **kwargs):
        r"""GetPoints(Geometry self, int nCoordDimension=0)"""
        return _ogr.Geometry_GetPoints(self, *args, **kwargs)

    def GetX(self, *args, **kwargs):
        r"""GetX(Geometry self, int point=0) -> double"""
        return _ogr.Geometry_GetX(self, *args, **kwargs)

    def GetY(self, *args, **kwargs):
        r"""GetY(Geometry self, int point=0) -> double"""
        return _ogr.Geometry_GetY(self, *args, **kwargs)

    def GetZ(self, *args, **kwargs):
        r"""GetZ(Geometry self, int point=0) -> double"""
        return _ogr.Geometry_GetZ(self, *args, **kwargs)

    def GetM(self, *args, **kwargs):
        r"""GetM(Geometry self, int point=0) -> double"""
        return _ogr.Geometry_GetM(self, *args, **kwargs)

    def GetPoint(self, *args):
        r"""GetPoint(Geometry self, int iPoint=0)"""
        return _ogr.Geometry_GetPoint(self, *args)

    def GetPointZM(self, *args):
        r"""GetPointZM(Geometry self, int iPoint=0)"""
        return _ogr.Geometry_GetPointZM(self, *args)

    def GetPoint_2D(self, *args):
        r"""GetPoint_2D(Geometry self, int iPoint=0)"""
        return _ogr.Geometry_GetPoint_2D(self, *args)

    def GetGeometryCount(self, *args):
        r"""GetGeometryCount(Geometry self) -> int"""
        return _ogr.Geometry_GetGeometryCount(self, *args)

    def SetPoint(self, *args, **kwargs):
        r"""SetPoint(Geometry self, int point, double x, double y, double z=0)"""
        return _ogr.Geometry_SetPoint(self, *args, **kwargs)

    def SetPointM(self, *args, **kwargs):
        r"""SetPointM(Geometry self, int point, double x, double y, double m)"""
        return _ogr.Geometry_SetPointM(self, *args, **kwargs)

    def SetPointZM(self, *args, **kwargs):
        r"""SetPointZM(Geometry self, int point, double x, double y, double z, double m)"""
        return _ogr.Geometry_SetPointZM(self, *args, **kwargs)

    def SetPoint_2D(self, *args, **kwargs):
        r"""SetPoint_2D(Geometry self, int point, double x, double y)"""
        return _ogr.Geometry_SetPoint_2D(self, *args, **kwargs)

    def SwapXY(self, *args):
        r"""
        SwapXY(Geometry self)

        Swap x and y coordinates.

        For more details: :cpp:func:`OGR_G_SwapXY`

        .. versionadded:: 2.3.0


        """
        return _ogr.Geometry_SwapXY(self, *args)

    def GetGeometryRef(self, *args):
        r"""GetGeometryRef(Geometry self, int geom) -> Geometry"""
        val = _ogr.Geometry_GetGeometryRef(self, *args)

        if val is not None:
            val._parent_geom = self


        return val


    def Simplify(self, *args):
        r"""
        Simplify(Geometry self, double tolerance) -> Geometry

        Compute a simplified geometry.

        For more details: :cpp:func:`OGR_G_Simplify`

        Parameters
        -----------
        tolerance: float
            The distance tolerance for the simplification.

        Returns
        --------
        Geometry:
            The simplified geometry or None if an error occurs.

        """
        return _ogr.Geometry_Simplify(self, *args)

    def SimplifyPreserveTopology(self, *args):
        r"""
        SimplifyPreserveTopology(Geometry self, double tolerance) -> Geometry

        Simplify the geometry while preserving topology.

        For more details: :cpp:func:`OGR_G_SimplifyPreserveTopology`

        Parameters
        -----------
        tolerance: float
            The distance tolerance for the simplification.

        Returns
        --------
        Geometry:
            The simplified geometry or None if an error occurs.

        """
        return _ogr.Geometry_SimplifyPreserveTopology(self, *args)

    def DelaunayTriangulation(self, *args, **kwargs):
        r"""
        DelaunayTriangulation(Geometry self, double dfTolerance=0.0, int bOnlyEdges=FALSE) -> Geometry

        Return a Delaunay triangulation of the vertices of the geometry.

        For more details: :cpp:func:`OGR_G_DelaunayTriangulation`

        .. versionadded:: 2.1

        Parameters
        -----------
        dfTolerance: float
            optional snapping tolerance to use for improved robustness
        bOnlyEdges: bool
            If True, will return a MULTILINESTRING, otherwise it will
            return a GEOMETRYCOLLECTION containing triangular POLYGONs.

        Returns
        --------
        Geometry:
            The geometry resulting from the Delaunay triangulation or None if an
            error occurs.

        """
        return _ogr.Geometry_DelaunayTriangulation(self, *args, **kwargs)

    def Polygonize(self, *args):
        r"""
        Polygonize(Geometry self) -> Geometry

        Polygonizes a set of sparse edges.

        For more details: :cpp:func:`OGR_G_Polygonize`

        Returns
        --------
        Geometry:
            A new geometry or None on failure.

        """
        return _ogr.Geometry_Polygonize(self, *args)

    def Boundary(self, *args):
        r"""
        Boundary(Geometry self) -> Geometry

        Compute boundary.

        For more details: :cpp:func:`OGR_G_Boundary`

        Returns
        --------
        Geometry:
            A new geometry or None on failure.

        """
        return _ogr.Geometry_Boundary(self, *args)

    def GetBoundary(self, *args):
        r"""
        GetBoundary(Geometry self) -> Geometry

        Compute boundary (deprecated)

        For more details: :cpp:func:`OGR_G_GetBoundary`

        ..warning:: Deprecated

        See: :cpp:func:`OGR_G_Boundary`

        """
        return _ogr.Geometry_GetBoundary(self, *args)

    def ConvexHull(self, *args):
        r"""
        ConvexHull(Geometry self) -> Geometry

        Compute convex hull.

        For more details: :cpp:func:`OGR_G_ConvexHull`

        Returns
        --------
        Geometry:
            a handle to A newly allocated geometry now owned by the caller, or
            None on failure.

        """
        return _ogr.Geometry_ConvexHull(self, *args)

    def ConcaveHull(self, *args):
        r"""ConcaveHull(Geometry self, double ratio, bool allowHoles) -> Geometry"""
        return _ogr.Geometry_ConcaveHull(self, *args)

    def MakeValid(self, *args):
        r"""
        MakeValid(Geometry self, char ** options=None) -> Geometry

        Attempts to make an invalid geometry valid without losing vertices.

        For more details: :cpp:func:`OGR_G_MakeValidEx`

        .. versionadded:: 3.0
        .. versionadded:: 3.4 options

        Parameters
        -----------
        options: list[str], optional
            papszOptions to be passed in. For example: ["METHOD=STRUCTURE"].

        Returns
        --------
        Geometry:
            A newly allocated geometry now owned by the caller, or None on
            failure.

        """
        return _ogr.Geometry_MakeValid(self, *args)

    def SetPrecision(self, *args):
        r"""SetPrecision(Geometry self, double gridSize, int flags=0) -> Geometry"""
        return _ogr.Geometry_SetPrecision(self, *args)

    def Normalize(self, *args):
        r"""
        Normalize(Geometry self) -> Geometry

        Attempts to bring geometry into normalized/canonical form.

        For more details: :cpp:func:`OGR_G_Normalize`

        .. versionadded:: 3.3

        Returns
        --------
        Geometry:
            A newly allocated geometry now owned by the caller, or None on
            failure.

        """
        return _ogr.Geometry_Normalize(self, *args)

    def RemoveLowerDimensionSubGeoms(self, *args):
        r"""RemoveLowerDimensionSubGeoms(Geometry self) -> Geometry"""
        return _ogr.Geometry_RemoveLowerDimensionSubGeoms(self, *args)

    def Buffer(self, *args, **kwargs):
        r"""
        Buffer(Geometry self, double distance, int quadsecs=30) -> Geometry

        Compute buffer of geometry.

        For more details: :cpp:func:`OGR_G_Buffer`

        Parameters
        -----------
        distance: float
            The buffer distance to be applied. Should be expressed into
            the same unit as the coordinates of the geometry.
        quadsecs: int, default=30
            The number of segments used to approximate a 90 degree
            (quadrant) of curvature.

        Returns
        --------
        Geometry:
            The newly created geometry or None if an error occurs.

        """
        return _ogr.Geometry_Buffer(self, *args, **kwargs)

    def Intersection(self, *args):
        r"""
        Intersection(Geometry self, Geometry other) -> Geometry

        Compute intersection.

        For more details: :cpp:func:`OGR_G_Intersection`

        Parameters
        -----------
        other: Geometry
            The other geometry.

        Returns
        --------
        Geometry:
            A new geometry representing the intersection or None if there is no
            intersection or an error occurs.

        """
        return _ogr.Geometry_Intersection(self, *args)

    def Union(self, *args):
        r"""
        Union(Geometry self, Geometry other) -> Geometry

        Compute union.

        For more details: :cpp:func:`OGR_G_Union`

        Parameters
        -----------
        other: Geometry
            The other geometry.

        Returns
        --------
        Geometry:
            A new geometry representing the union or None if an error occurs.

        """
        return _ogr.Geometry_Union(self, *args)

    def UnionCascaded(self, *args):
        r"""
        UnionCascaded(Geometry self) -> Geometry

        Compute union using cascading.

        For more deails: :cpp:func:`OGR_G_UnionCascaded`

        Returns
        --------
        Geometry:
            A new geometry representing the union or None if an error occurs.

        """
        return _ogr.Geometry_UnionCascaded(self, *args)

    def UnaryUnion(self, *args):
        r"""UnaryUnion(Geometry self) -> Geometry"""
        return _ogr.Geometry_UnaryUnion(self, *args)

    def Difference(self, *args):
        r"""
        Difference(Geometry self, Geometry other) -> Geometry

        Compute difference.

        For more details: :cpp:func:`OGR_G_Difference`

        Parameters
        -----------
        other: Geometry
            The other geometry.

        Returns
        --------
        Geometry:
            A new geometry representing the difference or None if the difference
            is empty or an error occurs.

        """
        return _ogr.Geometry_Difference(self, *args)

    def SymDifference(self, *args):
        r"""
        SymDifference(Geometry self, Geometry other) -> Geometry

        Compute symmetric difference.

        For more details: :cpp:func:`OGR_G_SymDifference`

        Parameters
        -----------
        other:
            the other geometry.

        Returns
        --------
        Geometry:
            A new geometry representing the symmetric difference or None if the
            difference is empty or an error occurs.

        """
        return _ogr.Geometry_SymDifference(self, *args)

    def SymmetricDifference(self, *args):
        r"""
        SymmetricDifference(Geometry self, Geometry other) -> Geometry

        Compute symmetric difference (deprecated)

        For more details: :cpp:func:`OGR_G_SymmetricDifference`

        .. warning:: Deprecated


        """
        return _ogr.Geometry_SymmetricDifference(self, *args)

    def Distance(self, *args):
        r"""
        Distance(Geometry self, Geometry other) -> double

        Compute distance between two geometries.

        For more details: :cpp:func:`OGR_G_Distance`

        Parameters
        -----------
        other: Geometry
            The other geometry to compare against.

        Returns
        --------
        float:
            The distance between the geometries or -1 if an error occurs.

        """
        return _ogr.Geometry_Distance(self, *args)

    def Distance3D(self, *args):
        r"""
        Distance3D(Geometry self, Geometry other) -> double

        Returns the 3D distance between two geometries.

        For more details: :cpp:func:`OGR_G_Distance3D`

        .. versionadded:: 2.2

        Parameters
        -----------
        other: Geometry
            The other geometry to compare against.

        Returns
        --------
        float:
            The distance between the geometries or -1 if an error occurs.

        """
        return _ogr.Geometry_Distance3D(self, *args)

    def Empty(self, *args):
        r"""
        Empty(Geometry self)

        Clear geometry information.

        For more details: :cpp:func:`OGR_G_Empty`

        """
        return _ogr.Geometry_Empty(self, *args)

    def IsEmpty(self, *args):
        r"""
        IsEmpty(Geometry self) -> bool

        Test if the geometry is empty.

        For more details: :cpp:func:`OGR_G_IsEmpty`

        Returns
        --------
        int:
            True if the geometry has no points, otherwise False.

        """
        return _ogr.Geometry_IsEmpty(self, *args)

    def IsValid(self, *args):
        r"""
        IsValid(Geometry self) -> bool

        Test if the geometry is valid.

        For more details: :cpp:func:`OGR_G_IsValid`

        Returns
        --------
        int:
            True if the geometry has no points, otherwise False.

        """
        return _ogr.Geometry_IsValid(self, *args)

    def IsSimple(self, *args):
        r"""
        IsSimple(Geometry self) -> bool

        Returns True if the geometry is simple.

        For more details: :cpp:func:`OGR_G_IsSimple`

        Returns
        --------
        int:
            True if object is simple, otherwise False.

        """
        return _ogr.Geometry_IsSimple(self, *args)

    def IsRing(self, *args):
        r"""
        IsRing(Geometry self) -> bool

        Test if the geometry is a ring.

        For more details: :cpp:func:`OGR_G_IsRing`

        Returns
        --------
        int:
            True if the geometry has no points, otherwise False.

        """
        return _ogr.Geometry_IsRing(self, *args)

    def Intersects(self, *args):
        r"""
        Intersects(Geometry self, Geometry other) -> bool

        Determines whether two geometries intersect.

        For more details: :cpp:func:`OGR_G_Intersects`

        Parameters
        -----------
        other: Geometry
            The other geometry to test against.

        Returns
        --------
        int:
            True if the geometries intersect, otherwise False.

        """
        return _ogr.Geometry_Intersects(self, *args)

    def Intersect(self, *args):
        r"""Intersect(Geometry self, Geometry other) -> bool"""
        return _ogr.Geometry_Intersect(self, *args)

    def Equals(self, *args):
        r"""
        Equals(Geometry self, Geometry other) -> bool

        Returns True if two geometries are equivalent.

        For more details: :cpp:func:`OGR_G_Equals`

        Parameters
        -----------
        other: Geometry
            The other geometry to test against.

        Returns
        --------
        int:
            True if equivalent or False otherwise.

        """
        return _ogr.Geometry_Equals(self, *args)

    def Equal(self, *args):
        r"""Equal(Geometry self, Geometry other) -> bool"""
        return _ogr.Geometry_Equal(self, *args)

    def Disjoint(self, *args):
        r"""
        Disjoint(Geometry self, Geometry other) -> bool

        Test for disjointness.

        For more details: :cpp:func:`OGR_G_Disjoint`

        Parameters
        -----------
        other: Geometry
            The other geometry to compare.

        Returns
        --------
        int:
            True if they are disjoint, otherwise False.

        """
        return _ogr.Geometry_Disjoint(self, *args)

    def Touches(self, *args):
        r"""
        Touches(Geometry self, Geometry other) -> bool

        Test for touching.

        For more details: :cpp:func:`OGR_G_Touches`

        Parameters
        -----------
        other:
            the other geometry to compare.

        Returns
        --------
        int:
            True if they are touching, otherwise False.

        """
        return _ogr.Geometry_Touches(self, *args)

    def Crosses(self, *args):
        r"""
        Crosses(Geometry self, Geometry other) -> bool

        Test for crossing.

        For more details: :cpp:func:`OGR_G_Crosses`

        Parameters
        -----------
        other: Geometry
            the other geometry to compare.

        Returns
        --------
        int:
            True if they are crossing, otherwise False.

        """
        return _ogr.Geometry_Crosses(self, *args)

    def Within(self, *args):
        r"""
        Within(Geometry self, Geometry other) -> bool

        Test for containment.

        For more details: :cpp:func:`OGR_G_Within`

        Parameters
        -----------
        other: Geometry
            the other geometry to compare.

        Returns
        --------
        int:
            True if this is within other, otherwise False.

        """
        return _ogr.Geometry_Within(self, *args)

    def Contains(self, *args):
        r"""
        Contains(Geometry self, Geometry other) -> bool

        Test for containment.

        For more details: :cpp:func:`OGR_G_Contains`

        Parameters
        -----------
        other: Geometry
            the other geometry to compare.

        Returns
        --------
        int:
            True if this contains the other geometry, otherwise False.

        """
        return _ogr.Geometry_Contains(self, *args)

    def Overlaps(self, *args):
        r"""
        Overlaps(Geometry self, Geometry other) -> bool

        Test for overlap.

        For more details: :cpp:func:`OGR_G_Overlaps`

        Parameters
        -----------
        other: Geometry
            the other geometry to compare.

        Returns
        --------
        int:
            True if they are overlapping, otherwise False.

        """
        return _ogr.Geometry_Overlaps(self, *args)

    def TransformTo(self, *args):
        r"""
        TransformTo(Geometry self, SpatialReference reference) -> OGRErr

        Transform geometry to new spatial reference system.

        For more details: :cpp:func:`OGR_G_TransformTo`

        Parameters
        -----------
        reference: SpatialReference
           The spatial reference system to apply.

        Returns
        --------
        int:
            :py:const:`osgeo.ogr.OGRERR_NONE` on success, or an error code.

        """
        return _ogr.Geometry_TransformTo(self, *args)

    def GetSpatialReference(self, *args):
        r"""
        GetSpatialReference(Geometry self) -> SpatialReference

        For more details: :cpp:func:`OGR_G_GetSpatialReference`

        Returns spatial reference system for geometry.

        Returns
        --------
        SpatialReference

        """
        return _ogr.Geometry_GetSpatialReference(self, *args)

    def AssignSpatialReference(self, *args):
        r"""
        AssignSpatialReference(Geometry self, SpatialReference reference)

        Assign spatial reference to this object.

        For more details: :cpp:func:`OGR_G_AssignSpatialReference`

        Parameters
        -----------
        reference: SpatialReference
            The new spatial reference system to apply.

        """
        return _ogr.Geometry_AssignSpatialReference(self, *args)

    def CloseRings(self, *args):
        r"""
        CloseRings(Geometry self)

        Force rings to be closed.

        For more details: :cpp:func:`OGR_G_CloseRings`

        """
        return _ogr.Geometry_CloseRings(self, *args)

    def FlattenTo2D(self, *args):
        r"""
        FlattenTo2D(Geometry self)

        Convert geometry to strictly 2D.

        For more details: :cpp:func:`OGR_G_FlattenTo2D`

        """
        return _ogr.Geometry_FlattenTo2D(self, *args)

    def Segmentize(self, *args):
        r"""
        Segmentize(Geometry self, double dfMaxLength)

        Modify the geometry such it has no segment longer then the given
        distance.

        For more details: :cpp:func:`OGR_G_Segmentize`

        Parameters
        -----------
        dfMaxLength: float
            the maximum distance between 2 points after segmentization

        """
        return _ogr.Geometry_Segmentize(self, *args)

    def GetEnvelope(self, *args):
        r"""
        GetEnvelope(Geometry self)

        Computes and returns the bounding envelope for this geometry in the
        passed psEnvelope structure.

        For more details: :cpp:func:`OGR_G_GetEnvelope`

        .. warning:: Check the return order of the bounds.

        Returns
        --------
        minx: float
        maxx: float
        miny: float
        maxy: float

        """
        return _ogr.Geometry_GetEnvelope(self, *args)

    def GetEnvelope3D(self, *args):
        r"""
        GetEnvelope3D(Geometry self)

        Computes and returns the bounding envelope (3D) for this geometry in
        the passed psEnvelope structure.

        For more details: :cpp:func:`OGR_G_GetEnvelope3D`

        .. warning:: Check the return order of the bounds.

        Returns
        --------
        minx: float
        maxx: float
        miny: float
        maxy: float
        minz: float
        maxz: float

        """
        return _ogr.Geometry_GetEnvelope3D(self, *args)

    def Centroid(self, *args):
        r"""
        Centroid(Geometry self) -> Geometry

        Compute the geometry centroid.

        For more details: :cpp:func:`OGR_G_Centroid`

        Returns
        --------
        Geometry

        """
        return _ogr.Geometry_Centroid(self, *args)

    def PointOnSurface(self, *args):
        r"""
        PointOnSurface(Geometry self) -> Geometry

        Returns a point guaranteed to lie on the surface.

        For more details: :cpp:func:`OGR_G_PointOnSurface`

        Returns
        --------
        Geometry:
            A point guaranteed to lie on the surface or None if an error occurred.

        """
        return _ogr.Geometry_PointOnSurface(self, *args)

    def WkbSize(self, *args):
        r"""
        WkbSize(Geometry self) -> size_t

        Returns size of related binary representation.

        For more details: :cpp:func:`OGR_G_WkbSize`

        Returns
        --------
        int

        """
        return _ogr.Geometry_WkbSize(self, *args)

    def GetCoordinateDimension(self, *args):
        r"""
        GetCoordinateDimension(Geometry self) -> int

        Get the dimension of the coordinates in this geometry.

        For more details: :cpp:func:`OGR_G_GetCoordinateDimension`

        .. warning:: Deprecated. Use :py:func:`CoordinateDimension`,
            :py:func:`Is3D`, or :py:func:`IsMeasured`.

        Returns
        --------
        int:
            This will return 2 or 3.

        """
        return _ogr.Geometry_GetCoordinateDimension(self, *args)

    def CoordinateDimension(self, *args):
        r"""
        CoordinateDimension(Geometry self) -> int

        Get the dimension of the coordinates in this geometry.

        For more details: :cpp:func:`OGR_G_CoordinateDimension`

        .. versionadded:: 2.1

        Returns
        --------
        int:
            This will return 2 for XY, 3 for XYZ and XYM, and 4 for XYZM data.

        """
        return _ogr.Geometry_CoordinateDimension(self, *args)

    def Is3D(self, *args):
        r"""
        Is3D(Geometry self) -> int

        See whether this geometry has Z coordinates.

        For more details: :cpp:func:`OGR_G_Is3D`

        .. versionadded:: 2.1

        Returns
        --------
        int:
            True if the geometry has Z coordinates.

        """
        return _ogr.Geometry_Is3D(self, *args)

    def IsMeasured(self, *args):
        r"""
        IsMeasured(Geometry self) -> int

        See whether this geometry is measured.

        For more details: :cpp:func:`OGR_G_IsMeasured`

        .. versionadded:: 2.1

        Returns
        --------
        int:
            True if the geometry has M coordinates.

        """
        return _ogr.Geometry_IsMeasured(self, *args)

    def SetCoordinateDimension(self, *args):
        r"""
        SetCoordinateDimension(Geometry self, int dimension)

        Set the coordinate dimension.

        For more details: :cpp:func:`OGR_G_SetCoordinateDimension`

        .. warning:: Deprecated. Use :py:func:`Set3D` or :py:func:`SetMeasured`.

        Parameters
        -----------
        dimension: int
            New coordinate dimension value, either 2 or 3.

        """
        return _ogr.Geometry_SetCoordinateDimension(self, *args)

    def Set3D(self, *args):
        r"""
        Set3D(Geometry self, int b3D)

        Add or remove the Z coordinate dimension.

        For more details: :cpp:func:`OGR_G_Set3D`

        .. versionadded:: 2.1

        Parameters
        -----------
        bIs3D: bool
            Should the geometry have a Z dimension, either True or False.

        """
        return _ogr.Geometry_Set3D(self, *args)

    def SetMeasured(self, *args):
        r"""
        SetMeasured(Geometry self, int bMeasured)

        Add or remove the M coordinate dimension.

        For more details: :cpp:func:`OGR_G_SetMeasured`

        .. versionadded:: 2.1

        Parameters
        -----------
        bIsMeasured: bool
            Should the geometry have a M dimension, either True or False.

        """
        return _ogr.Geometry_SetMeasured(self, *args)

    def GetDimension(self, *args):
        r"""
        GetDimension(Geometry self) -> int

        Get the dimension of this geometry.

        For more details: :cpp:func:`OGR_G_GetDimension`

        Returns
        --------
        int:
            0 for points, 1 for lines, and 2 for surfaces.

        """
        return _ogr.Geometry_GetDimension(self, *args)

    def HasCurveGeometry(self, *args):
        r"""HasCurveGeometry(Geometry self, int bLookForCircular=FALSE) -> int"""
        return _ogr.Geometry_HasCurveGeometry(self, *args)

    def GetLinearGeometry(self, *args, **kwargs):
        r"""GetLinearGeometry(Geometry self, double dfMaxAngleStepSizeDegrees=0.0, char ** options=None) -> Geometry"""
        return _ogr.Geometry_GetLinearGeometry(self, *args, **kwargs)

    def GetCurveGeometry(self, *args, **kwargs):
        r"""GetCurveGeometry(Geometry self, char ** options=None) -> Geometry"""
        return _ogr.Geometry_GetCurveGeometry(self, *args, **kwargs)

    def Value(self, *args):
        r"""Value(Geometry self, double dfDistance) -> Geometry"""
        return _ogr.Geometry_Value(self, *args)

    def Transform(self, *args):
        r"""
        Transform(Geometry self, CoordinateTransformation trans) -> OGRErr
        Transform(Geometry self, GeomTransformer transformer) -> Geometry

        Apply arbitrary coordinate transformation to geometry.

        For more details: :cpp:func:`OGR_G_Transform`

        Parameters
        -----------
        trans: CoordinateTransform
            The transformation to apply.

        Returns
        --------
        Geometry:
            The transformed geometry.

        """
        return _ogr.Geometry_Transform(self, *args)

    def CreatePreparedGeometry(self, *args):
        r"""CreatePreparedGeometry(Geometry self) -> PreparedGeometry"""
        return _ogr.Geometry_CreatePreparedGeometry(self, *args)

    def Destroy(self):
      self.__swig_destroy__(self)
      self.thisown = 0

    def __str__(self):
      return self.ExportToIsoWkt()

    def __copy__(self):
      return self.Clone()

    def __deepcopy__(self, memo):
      g = self.Clone()
      srs = self.GetSpatialReference()
      if srs:
          g.AssignSpatialReference(srs.Clone())
      return g

    def __reduce__(self):
      return (self.__class__, (), self.ExportToWkb())

    def __setstate__(self, state):
        result = CreateGeometryFromWkb(state)
        self.this = result.this

    def __iter__(self):
        for i in range(self.GetGeometryCount()):
            yield self.GetGeometryRef(i)


# Register Geometry in _ogr:
_ogr.Geometry_swigregister(Geometry)
class PreparedGeometry(object):
    r"""Proxy of C++ OGRPreparedGeometryShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_PreparedGeometry

    def Intersects(self, *args):
        r"""Intersects(PreparedGeometry self, Geometry otherGeom) -> bool"""
        return _ogr.PreparedGeometry_Intersects(self, *args)

    def Contains(self, *args):
        r"""Contains(PreparedGeometry self, Geometry otherGeom) -> bool"""
        return _ogr.PreparedGeometry_Contains(self, *args)

# Register PreparedGeometry in _ogr:
_ogr.PreparedGeometry_swigregister(PreparedGeometry)
class GeomTransformer(object):
    r"""Proxy of C++ OGRGeomTransformerShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""__init__(GeomTransformer self, CoordinateTransformation ct, char ** options=None) -> GeomTransformer"""
        _ogr.GeomTransformer_swiginit(self, _ogr.new_GeomTransformer(*args))
    __swig_destroy__ = _ogr.delete_GeomTransformer

    def Transform(self, *args):
        r"""Transform(GeomTransformer self, Geometry src_geom) -> Geometry"""
        return _ogr.GeomTransformer_Transform(self, *args)

# Register GeomTransformer in _ogr:
_ogr.GeomTransformer_swigregister(GeomTransformer)
class FieldDomain(object):
    r"""


    Python proxy of an :cpp:class:`OGRFieldDomain`.

    Created using one of:

    - :py:func:`CreateCodedFieldDomain`
    - :py:func:`CreateGlobFieldDomain`
    - :py:func:`CreateRangeFieldDomain`

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_FieldDomain

    def GetName(self, *args):
        r"""
        GetName(FieldDomain self) -> char const *


        Get the name of the field domain.

        See :cpp:func:`OGRFieldDomain::GetName`.

        .. versionadded:: 3.3

        Returns
        --------
        str
            the field domain name.

        """
        return _ogr.FieldDomain_GetName(self, *args)

    def GetDescription(self, *args):
        r"""
        GetDescription(FieldDomain self) -> char const *


        Get the description of the field domain.

        See :cpp:func:`OGRFieldDomain::GetDescription`.

        .. versionadded:: 3.3

        Returns
        --------
        str
            the field domain description (might be empty string).

        """
        return _ogr.FieldDomain_GetDescription(self, *args)

    def GetFieldType(self, *args):
        r"""
        GetFieldType(FieldDomain self) -> OGRFieldType


        Get the field type of the field domain.

        See :cpp:func:`OGRFieldDomain::GetFieldType`.

        .. versionadded:: 3.3

        Returns
        --------
        int
            the field type of the field domain.

        """
        return _ogr.FieldDomain_GetFieldType(self, *args)

    def GetFieldSubType(self, *args):
        r"""
        GetFieldSubType(FieldDomain self) -> OGRFieldSubType


        Get the field subtype of the field domain.

        See :cpp:func:`OGRFieldDomain::GetFieldSubType`.

        .. versionadded:: 3.3

        Returns
        --------
        int
            the field subtype of the field domain.

        """
        return _ogr.FieldDomain_GetFieldSubType(self, *args)

    def GetDomainType(self, *args):
        r"""
        GetDomainType(FieldDomain self) -> OGRFieldDomainType


        Get the type of the field domain.

        See :cpp:func:`OGRFieldDomain::GetDomainType`.

        .. versionadded:: 3.3

        Returns
        --------
        int
            the type of the field domain.

        Examples
        --------
        >>> d = ogr.CreateCodedFieldDomain('my_code', None, ogr.OFTInteger, ogr.OFSTNone, { 1 : 'owned', 2 : 'leased' })
        >>> d.GetDomainType() == ogr.OFDT_CODED
        True


        """
        return _ogr.FieldDomain_GetDomainType(self, *args)

    def GetSplitPolicy(self, *args):
        r"""
        GetSplitPolicy(FieldDomain self) -> OGRFieldDomainSplitPolicy


        Get the split policy of the field domain.

        See :cpp:func:`OGRFieldDomain::GetSplitPolicy`.

        .. versionadded:: 3.3

        Returns
        --------
        int
            the split policy of the field domain (default = :py:const:`OFDSP_DEFAULT_VALUE`)

        """
        return _ogr.FieldDomain_GetSplitPolicy(self, *args)

    def SetSplitPolicy(self, *args):
        r"""
        SetSplitPolicy(FieldDomain self, OGRFieldDomainSplitPolicy policy)


        Set the split policy of the field domain.

        See :cpp:func:`OGRFieldDomain::SetSplitPolicy`.

        .. versionadded:: 3.3

        policy : int
            the split policy code of the field domain.

        """
        return _ogr.FieldDomain_SetSplitPolicy(self, *args)

    def GetMergePolicy(self, *args):
        r"""
        GetMergePolicy(FieldDomain self) -> OGRFieldDomainMergePolicy


        Get the merge policy of the field domain.

        See :cpp:func:`OGRFieldDomain::GetMergePolicy`.

        .. versionadded:: 3.3

        Returns
        --------
        int
            the merge policy of the field domain (default = :py:const:`OFDMP_DEFAULT_VALUE`)

        """
        return _ogr.FieldDomain_GetMergePolicy(self, *args)

    def SetMergePolicy(self, *args):
        r"""
        SetMergePolicy(FieldDomain self, OGRFieldDomainMergePolicy policy)


        Set the merge policy of the field domain.

        See :cpp:func:`OGRFieldDomain::SetMergePolicy`.

        .. versionadded:: 3.3

        Parameters
        -----------
        policy : int
            the merge policy code of the field domain.

        """
        return _ogr.FieldDomain_SetMergePolicy(self, *args)

    def GetEnumeration(self, *args):
        r"""
        GetEnumeration(FieldDomain self) -> OGRCodedValue const *


        Get the enumeration as a mapping of codes to values.

        See :cpp:func:`OGRCodedFieldDomain::GetEnumeration`.

        .. versionadded:: 3.3

        Returns
        --------
        dict

        Examples
        --------
        >>> d = ogr.CreateCodedFieldDomain('my_domain', None, ogr.OFTInteger, ogr.OFSTNone, { 1 : 'owned', 2 : 'leased' })
        >>> d.GetEnumeration()
        {'1': 'owned', '2': 'leased'}


        """
        return _ogr.FieldDomain_GetEnumeration(self, *args)

    def GetMinAsDouble(self, *args):
        r"""
        GetMinAsDouble(FieldDomain self) -> double


        Get the minimum value of a range domain.

        See :cpp:func:`OGRRangeFieldDomain::GetMin()`

        .. versionadded:: 3.3

        Returns
        --------
        float
            the minimum value of the range

        """
        return _ogr.FieldDomain_GetMinAsDouble(self, *args)

    def GetMinAsString(self, *args):
        r"""
        GetMinAsString(FieldDomain self) -> char const *


        Get the minimum value of a range domain.

        See :cpp:func:`OGRRangeFieldDomain::GetMin()`

        .. versionadded:: 3.3

        Returns
        --------
        str
            the minimum value of the range

        """
        return _ogr.FieldDomain_GetMinAsString(self, *args)

    def IsMinInclusive(self, *args):
        r"""IsMinInclusive(FieldDomain self) -> bool"""
        return _ogr.FieldDomain_IsMinInclusive(self, *args)

    def GetMaxAsDouble(self, *args):
        r"""
        GetMaxAsDouble(FieldDomain self) -> double


        Get the maximum value of a range domain.

        See :cpp:func:`OGRRangeFieldDomain::GetMax()`

        .. versionadded:: 3.3

        Returns
        --------
        float
            the maximum value of the range

        """
        return _ogr.FieldDomain_GetMaxAsDouble(self, *args)

    def GetMaxAsString(self, *args):
        r"""
        GetMaxAsString(FieldDomain self) -> char const *


        Get the maximum value of a range domain.

        See :cpp:func:`OGRRangeFieldDomain::GetMax()`

        .. versionadded:: 3.3

        Returns
        --------
        str
            the maximum value of the range

        """
        return _ogr.FieldDomain_GetMaxAsString(self, *args)

    def IsMaxInclusive(self, *args):
        r"""IsMaxInclusive(FieldDomain self) -> bool"""
        return _ogr.FieldDomain_IsMaxInclusive(self, *args)

    def GetGlob(self, *args):
        r"""
        GetGlob(FieldDomain self) -> char const *


        Get the glob expression.

        See :cpp:func:`OGRGlobFieldDomain::GetGlob`.

        .. versionadded:: 3.3

        Returns
        --------
        str
            the glob expression, or ``None`` in case of error

        """
        return _ogr.FieldDomain_GetGlob(self, *args)

# Register FieldDomain in _ogr:
_ogr.FieldDomain_swigregister(FieldDomain)

def CreateCodedFieldDomain(*args):
    r"""
    CreateCodedFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, OGRCodedValue const * enumeration) -> FieldDomain


    Creates a new coded field domain.

    See :cpp:func:`OGRCodedFieldDomain::OGRCodedFieldDomain`.

    .. versionadded:: 3.3

    Parameters
    -----------
    name : str
        Domain name. Should not be ``None``.
    description : str, optional
        Domain description (can be ``None``)
    type : int
        Field type.
    subtype : int
        Field subtype.
    enumeration : dict
        Enumeration as a dictionary of (code : value) pairs. Should not be ``None``.

    Returns
    --------
    FieldDomain

    """
    return _ogr.CreateCodedFieldDomain(*args)

def CreateRangeFieldDomain(*args):
    r"""
    CreateRangeFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, double min, bool minIsInclusive, double max, double maxIsInclusive) -> FieldDomain

    Creates a new range field domain.

    See :cpp:func:`OGRRangeFieldDomain::OGRRangeFieldDomain`.

    .. versionadded:: 3.3

    Parameters
    -----------
    name : str
        Domain name. Should not be ``None``.
    description : str, optional
        Domain description (can be ``None``)
    type : int
        Field type. Generally numeric. Potentially :py:const:`OFTDateTime`.
    subtype : int
        Field subtype.
    min : float, optional
        Minimum value (can be ``None``).
    minIsInclusive : bool
        Whether the minimum value is included in the range.
    max : float, optional
        Maximum value (can be ``None``).
    maxIsInclusive : bool
        Whether the maximum value is included in the range.

    Returns
    --------
    FieldDomain

    """
    return _ogr.CreateRangeFieldDomain(*args)

def CreateRangeFieldDomainDateTime(*args):
    r"""CreateRangeFieldDomainDateTime(char const * name, char const * description, char const * min, bool minIsInclusive, char const * max, double maxIsInclusive) -> FieldDomain"""
    return _ogr.CreateRangeFieldDomainDateTime(*args)

def CreateGlobFieldDomain(*args):
    r"""
    CreateGlobFieldDomain(char const * name, char const * description, OGRFieldType type, OGRFieldSubType subtype, char const * glob) -> FieldDomain


    Creates a new glob field domain.

    See :cpp:func:`OGRGlobFieldDomain::OGRGlobFieldDomain`

    .. versionadded:: 3.3

    Parameters
    -----------
    name : str
        Domain name. Should not be ``None``.
    description : str, optional
        Domain description (can be ``None``)
    type : int
        Field type.
    subtype : int
        Field subtype.
    glob : str
        Glob expression. Should not be ``None``.

    Returns
    --------
    FieldDomain

    """
    return _ogr.CreateGlobFieldDomain(*args)
class GeomCoordinatePrecision(object):
    r"""Proxy of C++ OGRGeomCoordinatePrecisionShadow class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ogr.delete_GeomCoordinatePrecision

    def Set(self, *args):
        r"""Set(GeomCoordinatePrecision self, double xyResolution, double zResolution, double mResolution)"""
        return _ogr.GeomCoordinatePrecision_Set(self, *args)

    def SetFromMeter(self, *args):
        r"""SetFromMeter(GeomCoordinatePrecision self, SpatialReference srs, double xyMeterResolution, double zMeterResolution, double mResolution)"""
        return _ogr.GeomCoordinatePrecision_SetFromMeter(self, *args)

    def GetXYResolution(self, *args):
        r"""GetXYResolution(GeomCoordinatePrecision self) -> double"""
        return _ogr.GeomCoordinatePrecision_GetXYResolution(self, *args)

    def GetZResolution(self, *args):
        r"""GetZResolution(GeomCoordinatePrecision self) -> double"""
        return _ogr.GeomCoordinatePrecision_GetZResolution(self, *args)

    def GetMResolution(self, *args):
        r"""GetMResolution(GeomCoordinatePrecision self) -> double"""
        return _ogr.GeomCoordinatePrecision_GetMResolution(self, *args)

    def GetFormats(self, *args):
        r"""GetFormats(GeomCoordinatePrecision self) -> char **"""
        return _ogr.GeomCoordinatePrecision_GetFormats(self, *args)

    def GetFormatSpecificOptions(self, *args):
        r"""GetFormatSpecificOptions(GeomCoordinatePrecision self, char const * formatName) -> char **"""
        return _ogr.GeomCoordinatePrecision_GetFormatSpecificOptions(self, *args)

    def SetFormatSpecificOptions(self, *args):
        r"""SetFormatSpecificOptions(GeomCoordinatePrecision self, char const * formatName, char ** formatSpecificOptions)"""
        return _ogr.GeomCoordinatePrecision_SetFormatSpecificOptions(self, *args)

# Register GeomCoordinatePrecision in _ogr:
_ogr.GeomCoordinatePrecision_swigregister(GeomCoordinatePrecision)

def CreateGeomCoordinatePrecision(*args):
    r"""CreateGeomCoordinatePrecision() -> GeomCoordinatePrecision"""
    return _ogr.CreateGeomCoordinatePrecision(*args)

def GetDriverCount(*args):
    r"""GetDriverCount() -> int"""
    return _ogr.GetDriverCount(*args)

def GetOpenDSCount(*args):
    r"""GetOpenDSCount() -> int"""
    return _ogr.GetOpenDSCount(*args)

def SetGenerate_DB2_V72_BYTE_ORDER(*args):
    r"""SetGenerate_DB2_V72_BYTE_ORDER(int bGenerate_DB2_V72_BYTE_ORDER) -> OGRErr"""
    return _ogr.SetGenerate_DB2_V72_BYTE_ORDER(*args)

def RegisterAll(*args):
    r"""RegisterAll()"""
    return _ogr.RegisterAll(*args)

def GeometryTypeToName(*args):
    r"""GeometryTypeToName(OGRwkbGeometryType eType) -> char const *"""
    return _ogr.GeometryTypeToName(*args)

def GetFieldTypeName(*args):
    r"""
    GetFieldTypeName(OGRFieldType type) -> char const *

    Fetch human readable name for a field type.

    See :cpp:func:`OGRFieldDefn::GetFieldTypeName`.

    Parameters
    -----------
    type : int
        the field type code to get name for

    Returns
    --------
    str
        the name

    Examples
    --------
    >>> ogr.GetFieldTypeName(0)
    'Integer'

    >>> ogr.GetFieldTypeName(ogr.OFTReal)
    'Real'

    """
    return _ogr.GetFieldTypeName(*args)

def GetFieldSubTypeName(*args):
    r"""
    GetFieldSubTypeName(OGRFieldSubType type) -> char const *


    Fetch human readable name for a field subtype.

    See :cpp:func:`OGRFieldDefn::GetFieldSubTypeName`.

    Parameters
    -----------
    type : int
        the field subtype to get name for.

    Returns
    --------
    str
        the name.

    Examples
    --------
    >>> ogr.GetFieldSubTypeName(1)
    'Boolean'

    >>> ogr.GetFieldSubTypeName(ogr.OFSTInt16)
    'Int16'


    """
    return _ogr.GetFieldSubTypeName(*args)

def GT_Flatten(*args):
    r"""GT_Flatten(OGRwkbGeometryType eType) -> OGRwkbGeometryType"""
    return _ogr.GT_Flatten(*args)

def GT_SetZ(*args):
    r"""GT_SetZ(OGRwkbGeometryType eType) -> OGRwkbGeometryType"""
    return _ogr.GT_SetZ(*args)

def GT_SetM(*args):
    r"""GT_SetM(OGRwkbGeometryType eType) -> OGRwkbGeometryType"""
    return _ogr.GT_SetM(*args)

def GT_SetModifier(*args):
    r"""GT_SetModifier(OGRwkbGeometryType eType, int bSetZ, int bSetM=FALSE) -> OGRwkbGeometryType"""
    return _ogr.GT_SetModifier(*args)

def GT_HasZ(*args):
    r"""GT_HasZ(OGRwkbGeometryType eType) -> int"""
    return _ogr.GT_HasZ(*args)

def GT_HasM(*args):
    r"""GT_HasM(OGRwkbGeometryType eType) -> int"""
    return _ogr.GT_HasM(*args)

def GT_IsSubClassOf(*args):
    r"""GT_IsSubClassOf(OGRwkbGeometryType eType, OGRwkbGeometryType eSuperType) -> int"""
    return _ogr.GT_IsSubClassOf(*args)

def GT_IsCurve(*args):
    r"""GT_IsCurve(OGRwkbGeometryType arg1) -> int"""
    return _ogr.GT_IsCurve(*args)

def GT_IsSurface(*args):
    r"""GT_IsSurface(OGRwkbGeometryType arg1) -> int"""
    return _ogr.GT_IsSurface(*args)

def GT_IsNonLinear(*args):
    r"""GT_IsNonLinear(OGRwkbGeometryType arg1) -> int"""
    return _ogr.GT_IsNonLinear(*args)

def GT_GetCollection(*args):
    r"""GT_GetCollection(OGRwkbGeometryType eType) -> OGRwkbGeometryType"""
    return _ogr.GT_GetCollection(*args)

def GT_GetCurve(*args):
    r"""GT_GetCurve(OGRwkbGeometryType eType) -> OGRwkbGeometryType"""
    return _ogr.GT_GetCurve(*args)

def GT_GetLinear(*args):
    r"""GT_GetLinear(OGRwkbGeometryType eType) -> OGRwkbGeometryType"""
    return _ogr.GT_GetLinear(*args)

def SetNonLinearGeometriesEnabledFlag(*args):
    r"""SetNonLinearGeometriesEnabledFlag(int bFlag)"""
    return _ogr.SetNonLinearGeometriesEnabledFlag(*args)

def GetNonLinearGeometriesEnabledFlag(*args):
    r"""GetNonLinearGeometriesEnabledFlag() -> int"""
    return _ogr.GetNonLinearGeometriesEnabledFlag(*args)

def GetOpenDS(*args):
    r"""GetOpenDS(int ds_number) -> DataSource"""
    return _ogr.GetOpenDS(*args)

def Open(*args, **kwargs):
    r"""Open(char const * utf8_path, int update=0) -> DataSource"""

    _WarnIfUserHasNotSpecifiedIfUsingExceptions()


    return _ogr.Open(*args, **kwargs)

def OpenShared(*args, **kwargs):
    r"""OpenShared(char const * utf8_path, int update=0) -> DataSource"""
    return _ogr.OpenShared(*args, **kwargs)

def GetDriverByName(*args):
    r"""GetDriverByName(char const * name) -> Driver"""
    return _ogr.GetDriverByName(*args)

def GetDriver(*args):
    r"""GetDriver(int driver_number) -> Driver"""
    return _ogr.GetDriver(*args)

def GeneralCmdLineProcessor(*args):
    r"""GeneralCmdLineProcessor(char ** papszArgv, int nOptions=0) -> char **"""

    import os
    for i in range(len(args[0])):
        if isinstance(args[0][i], (os.PathLike, int)):
            args[0][i] = str(args[0][i])


    return _ogr.GeneralCmdLineProcessor(*args)

def TermProgress_nocb(*args, **kwargs):
    r"""TermProgress_nocb(double dfProgress, char const * pszMessage=None, void * pData=None) -> int"""
    return _ogr.TermProgress_nocb(*args, **kwargs)
TermProgress = _ogr.TermProgress


